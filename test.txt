 

welcome to my first code in github
 
#selective sorting

def sort(nums):
    
    for i in range(len(nums)):
        minval = i 
        for j in range(i,len(nums)):
            if nums[j]<nums[minval]:
                minval = j

        temp = nums[i]
        nums[i]= nums[minval]
        nums[minval] = temp


nums = [5,3,8,6,7,2]
sort(nums)

print(nums)
 

#bubble sorting

def sort(nums):
    for i in range(len(nums)- 1 , 0 , -1):
        for j in range(i):
            if nums[j]> nums[j+1]:
                temp = nums[j]
                nums[j]= nums[j+1]
                nums[j+1]= temp


nums = [5,2,6,8,9,4]
sort(nums)
print(nums)


#this is a calculator

def add(a,b):
    result = a + b 
    print(result)

def sub(a,b):
    result = a - b
    print(result)

def mul(a,b):
    result = a * b 
    print(result)

def div(a,b):
    result = a / b 
    print(result)

a = int(input("enter the first number:"))
b = int(input("enter the second number:"))
op = input("enter the operator:")

if op == "+":
    add(a,b)
elif op == "-":
    sub(a,b)
elif op == "*":
    mul (a,b)
elif op == "/":
    div(a,b)
else:
    print("invalid operator")
    
    
#this is a countdown timer 

import time

def countdown(t):

    while t:
        mins , secs =  divmod( t , 60)
        timer = '{:02d} : {:02d}' . format(mins , secs)
        print(timer )
        time.sleep(1)
        t -= 1

    print("you are killed")

t = int(input("enter the number of seconds"))
countdown(int(t))

#clock

from tkinter import *
from tkinter.ttk import *
from time import strftime

root = Tk()
root.title("clock")

def time():
    string = strftime('%H:%M:%S %p')
    label.config(text=string)
    label.after(1000, time)

label = Label(root , font=("western_bang_bang" , 50) , background= "black", foreground = "cyan")
label.pack(anchor="center")
time()

mainloop()

#hangman 

import random

with open('words.txt', 'r') as f:
    words = f.readlines()

word = random.choice(words)[:-1]

allowed_errors = 7 
guesses =[]
done = False

while not done:
    for letter in word :
        if letter.lower() in guesses:
            print(letter, end=" ")
        else:
            print("_", end=" ")
    print("")
    

    guess = input(f"Allowed_errors left{allowed_errors}, Next guess:")
    guesses.append(guess.lower())
    if guess.lower() not in word.lower():
        allowed_errors -= 1
        if allowed_errors == 0:
            break

    done = True
    for letter in word:
        if letter.lower() not in guesses:
            done = False

if done:
    print(f"you found the word! it was {word}")
else:
    print(f"game over! the word was {word}")
    
    
    
#snake game made 


import random
import pygame
import time

from pygame.constants import WINDOWHITTEST

pygame.init()

white = (255, 255 , 255)
black = (0, 0, 0)
red = (255 ,0 , 0 )
orange = (255 , 165 , 0)


width, height = 600 , 400


game_display = pygame.display.set_mode((width , height))
pygame.display.set_caption("anay's snake game")

clock = pygame.time.Clock()

snake_size = 10
snake_speed = 10

message_font = pygame.font.SysFont('ubuntu' , 30)
score_font = pygame.font.SysFont('ubuntu' , 25)

def print_score(score):
    text = score_font.render("Score:" + str(score), True , orange)
    game_display.blit(text, [0,0])

def draw_snake(snake_size, snake_pixels):
    for pixels in snake_pixels:
        pygame.draw.rect(game_display, white , [pixels[0], pixels[1] , snake_size , snake_size])

def run_game():


    game_over = False
    game_close = False

    x = width / 2
    y = height / 2 

    x_speed = 0
    y_speed = 0

    snake_pixels =[]
    snake_length = 1

    target_x = round(random.randrange(0, width -snake_size) / 10.0) * 10.0
    target_y = round(random.randrange(0, height -snake_size) / 10.0) * 10.0

    while not game_over:

        while game_close:
            game_display.fill(black)
            game_over_message = message_font.render("game over!" , True , red)
            game_display.blit(game_over_message, [width / 3 , height / 3 ])
            print_score(snake_length - 1 )
            pygame.display.update()

            for event in pygame.event.get():
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_1:
                        game_over = True
                        game_close = False
                    if event.key == pygame.K_2:
                        run_game()
                if event.type == pygame.QUIT:
                    game_over = True
                    game_close = False                    

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                game_over = True
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_LEFT:
                    x_speed = -snake_size
                    y_speed = 0
                if event.key == pygame.K_RIGHT:
                    x_speed = snake_size
                    y_speed = 0 
                if event.key == pygame.K_UP:
                    x_speed = 0
                    y_speed = -snake_size
                if event.key == pygame.K_DOWN:
                    x_speed = 0
                    y_speed = snake_size

        if x>= width or x < 0 or y>=height or y < 0 :
            game_close = True

        x += x_speed 
        y += y_speed


        game_display.fill(black)
        pygame.draw.rect(game_display , orange , [target_x, target_y, snake_size, snake_size])

        snake_pixels.append([x,y])

        if len(snake_pixels) > snake_length :
            del snake_pixels[0]

        for pixels in snake_pixels[:-1]:
            if pixels == [x,y]:
                game_close = True

        draw_snake(snake_size, snake_pixels)
        print_score(snake_length - 1)

        pygame.display.update()

        if x == target_x and y == target_y:
            target_x = round(random.randrange(0, width -snake_size) / 10.0) * 10.0
            target_y = round(random.randrange(0, height -snake_size) / 10.0) * 10.0
            snake_length += 1

        clock.tick(snake_speed)

    pygame.quit()
    quit()

run_game()

#flappybird game made

import pygame
import neat
import time
import os
import random
pygame.font.init()

WIN_WIDTH = 700
WIN_HEIGHT = 700

BIRD_IMGS = [pygame.transform.scale2x(pygame.image.load(os.path.join("imgs", "bird1.png"))), pygame.transform.scale2x(pygame.image.load(os.path.join("imgs", "bird2.png"))), pygame.transform.scale2x(pygame.image.load(os.path.join("imgs", "bird3.png")))]
PIPE_IMG = pygame.transform.scale2x(pygame.image.load(os.path.join("imgs", "pipe.png")))
BASE_IMG = pygame.transform.scale2x(pygame.image.load(os.path.join("imgs", "base.png")))
BG_IMG = pygame.transform.scale2x(pygame.image.load(os.path.join("imgs", "bg.png")))

STAT_FONT = pygame.font.SysFont("DejaVu Sans" , 50)

class Bird:
    IMGS = BIRD_IMGS
    MAX_ROTATION = 25
    ROT_VEL = 20
    ANIMATION_TIME = 5

    def __init__(self , x , y):
        self.x = x
        self.y = y 
        self.tilt = 0 
        self.tick_count = 0
        self.vel = 0
        self.height = self.y
        self.img_count = 0
        self.img = self.IMGS[0]

    def jump(self):
        self.vel = -10.5
        self.tick_count = 0
        self.height = self.y

    def move(self):
        self.tick_count += 1

        d = self.vel*self.tick_count + 1.5*self.tick_count**2

        if d >= 16:
            d = 16

        if d < 0:
            d -= 2

        self.y = self.y + d

        if d < 0 or self.y < self.height + 50:
            if self.tilt < self.MAX_ROTATION:
                self.tilt = self.MAX_ROTATION
            else:
                if self.tilt > -90:
                    self.tilt -= self.ROT_VEL

    def draw(self , win):
        self.img_count += 1

        if self.img_count < self.ANIMATION_TIME:
            self.img = self.IMGS[0]
        elif self.img_count < self.ANIMATION_TIME*2:
            self.img = self.IMGS[1]
        elif self.img_count < self.ANIMATION_TIME*3:
            self.img = self.IMGS[2]
        elif self.img_count < self.ANIMATION_TIME*4:
            self.img = self.IMGS[1]
        elif self.img_count == self.ANIMATION_TIME*4 + 1:
            self.img = self.IMGS[0]
            self.img_count = 0

        if self.tilt <= -80:
            self.img = self.IMGS[1]
            self.img_count = self.ANIMATION_TIME*2

        rotated_image = pygame.transform.rotate(self.img , self.tilt)
        new_rect = rotated_image.get_rect(center=self.img.get_rect(topleft = (self.x , self.y)).center)
        win.blit(rotated_image , new_rect.topleft)

    def get_mask(self):
        return pygame.mask.from_surface(self.img)

class Pipe:
    GAP = 200
    VEL = 5
    
    def __init__(self , x):
        self.x = x
        self.height = 0
        

        self.top = 0
        self.bottom = 0
        self.PIPE_TOP = pygame.transform.flip(PIPE_IMG , False , True)
        self.PIPE_BOTTOM = PIPE_IMG

        self.passed = False
        self.set_height()

    def set_height(self):
        self.height = random.randrange(50 , 450)
        self.top = self.height - self.PIPE_TOP.get_height()
        self.bottom = self.height + self.GAP

    def move(self):
        self.x -= self.VEL

    def draw(self , win):
        win.blit(self.PIPE_TOP , (self.x , self.top))
        win.blit(self.PIPE_BOTTOM, (self.x, self.bottom))

    def collide(self , bird):
        bird_mask = bird.get_mask()
        top_mask =  pygame.mask.from_surface(self.PIPE_TOP)
        bottom_mask =  pygame.mask.from_surface(self.PIPE_BOTTOM)

        top_offset = (self.x - bird.x , self.top - round(bird.y))
        bottom_offset = (self.x - bird.x , self.bottom - round(bird.y))

        b_point = bird_mask.overlap(bottom_mask , bottom_offset)
        t_point = bird_mask.overlap(top_mask , top_offset)

        if t_point or b_point:
            return True

        return False
        
class Base:
    VEL = 5
    WIDTH = BASE_IMG.get_width()
    IMG = BASE_IMG

    def __init__(self, y):
        self.y = y 
        self.x1 = 0
        self.x2 = self.WIDTH

    def move(self):
        self.x1 -= self.VEL
        self.x2 -= self.VEL

        if self.x1 + self.WIDTH < 0:
            self.x1 = self.x2 + self.WIDTH

        if self.x2 + self.WIDTH < 0:
            self.x2 = self.x1 + self.WIDTH

    def draw(self , win):
        win.blit(self.IMG , (self.x1 , self.y))
        win.blit(self.IMG , (self.x2 , self.y))

def draw_window(win , birds , pipes, base , score):
    win.blit(BG_IMG , (0,0))

    for pipe in pipes:
        pipe.draw(win)

    text = STAT_FONT.render("Score" + str(score), 1, (255,255,255))
    win.blit(text , (WIN_WIDTH - 10 - text.get_width() , 10))


    base.draw(win)

    for bird in birds:
        bird.draw(win)

    pygame.display.update()

def main(genomes , config):
    nets = []
    ge = []
    birds = []

    for _, g in genomes:
        net = neat.nn.FeedForwardNetwork.create(g , config)
        nets.append
        birds.append(Bird(230 , 350))
        g.fitness = 0
        ge.append(g)


    base = Base(730)
    pipes = [Pipe(600)]
    win = pygame.display.set_mode((WIN_WIDTH , WIN_HEIGHT))
    clock = pygame.time.Clock()

    score = 0 

    run = True
    while run:
        clock.tick(30)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False
                pygame.quit()
                quit()


        pipe_ind = 0
        if len(birds) > 0:
            if len(pipes) > 1 and birds[0].x > pipes[0].x + pipes[0].PIPE_TOP.get_width():
                pipe_ind = 1
        else:
            run = False
            break


        for x , bird in enumerate(birds):
            bird.move()
            ge[x].fitness += 0.1

            output = nets[x].activate((bird.y , abs(bird.y - pipes[pipe_ind].height) , abs(bird.y - pipes[pipe_ind].bottom)))

            if output[0] > 0.5:
                bird.jump()


        add_pipe = False
        rem = []
        base.move()
        for pipe in pipes:
            for x, bird in enumerate(birds):
                if pipe.collide(bird):
                    ge[x].fitness -= 1
                    birds.pop(x)
                    nets.pop(x)
                    ge.pop(x)
                       
            
                if not pipe.passed and pipe.x < bird.x:
                    pipe.passed = True
                    add_pipe = True

            if pipe.x + pipe.PIPE_TOP.get_width() < 0:
                rem.append(pipe)

            pipe.move()   

        if add_pipe:
            score += 1
            for g in ge:
                g.fitness += 5
            pipes.append(Pipe(600))
        
        for r in rem:
            pipes.remove(r)

        for bird in birds:
            if bird.y + bird.img.get_height() >= 730 or bird.y < 0:
                birds.pop(x)
                nets.pop(x)
                ge.pop(x)
                
        
        base.move()
        draw_window(win , birds , pipes , base , score)


def run(config_path):
    config = neat.config.Config(neat.DefaultGenome , neat.DefaultReproduction , 
                     neat.DefaultSpeciesSet , neat.DefaultStagnation ,
                     config_path)

    p = neat.Population(config)

    p.add_reporter(neat.StdOutReporter(True))
    stats = neat.StatisticsReporter()
    p.add_reporter(stats)

    winner = p.run(main, 50)

if __name__ == "__main__":
    local_dir = os.path.dirname(__file__)
    config_path = os.path.join(local_dir , "config-feedforward.txt")
    run(config_path)



# for printing  : anay's "laptop"

print('anay\'s "laptop"')


# simple codes 

num = [23 , 45  , 73 , 47 , 67]

num.append(44)
num.remove(23)
num.insert(3 , 99)
num.pop(2)
num.extend([22 , 76, 56, 41 , 11])
del num[3:]

print(num)

################

# new codes 



# dictionary


data = {1:'navin' , 2: 'kiran' ,4: 'anay' }

print(data[1])
print(data.get(3, "not found"))
print(data.get(4))

print(data.keys())

keys = ['ramesh' , 'kiran' , 'animesh']  
values = ['python' , 'javascript' , 'ruby']
data2 = dict(zip(keys , values))
print(data2)

data2['monika'] = 'c #'
print(data2)

del data2['ramesh']
print(data2)

# dictionary within dictionary

prog = {'js' : 'atom', 'cs': 'vs', 'python': ['sublime' ,'pycharm'] , 'java' : {'jse' : 'netbeans' , 'jee': 'eclipse'}}
print(prog['js'])
print(prog['python'][1])
print(prog['java']['jee'])

# data types

num = 3.5

print(type(num))

num2 = int(num)
print(num2)

print(int(True))


print(list(range(10)))
print(list(range(2,10,3)))

# operators

x = 2
y = 4

x += 2

print(x * y )

# binary system

print(bin(25))
print(bin(20))
print(bin(100))
print(int(0b11001))
print(oct(25))
print(hex(10))

#############

# more codes 

# swap two variables 

a = 4
b = 5

c = a 
a = b 
b = c

print(a)
print(b)


a = a + b   # a = 5 + 4 = 9
b = a - b   # b = 9 - 5 = 4
a = a - b   # a = 9 - 4 = 5

print(a)
print(b)

a , b = b ,a 

print(a)
print(b)


# important maths functions

import math as m 

print(m.sqrt(25))
print(m.floor(3.8))
print(m.ceil(2.1))
print(m.pow(3,4))


# code to print the greatest number out of three values taken from the user

x = int(input("enter your number"))
y = int(input("enter your number"))
z = int(input("enter your number"))

if x > y and x > z:
    print(x , "is the greatest number")
elif y > x and y > z:
    print(y , "is the greatest number")
elif z > x and z > x:
    print(z , "is the greatest number")
else:
    print("all are equal")

# some more codes about while loop



i = 1 

while i <=5:
    print("hello " , end = "")
    j = 1
    while j <= 5:
        print("rocks " , end= "")
        j = j + 1
    
    i += 1 
    print()


# code to print all values from 1 to 100 without printing the numbers divisible by 3 or 5


b = 1
a = 1
while b<= 100:
    if a % 5 == 0 or a % 3 == 0:
        a = a + 1
    else:
        print(a)
        a = a + 1
    b = b + 1
    
# code to print
# # # # # 
# # # # #
# # # # #
# # # # # 


x = 1


while x <= 4:
    print("# " , end = "" )
    y = 1
    while y <= 4:
        print("# " , end = "" )
        y = y + 1
    x = x + 1
    print()

for i in range(1,5):
    print("# " , end = "")
    for y in range(1,5):
        print("# " , end = "")

    print()

# break and continue

#### remark - the 'pass' keyword will behave as 'continue' keyword if we give an else block to the if block to which we have given the 'pass' 
                  command . 'break' simply stops the loop. continue and pass commands will tell the loop to skip the code(as specified).
                  the only difference is that pass needs an else block while continue command does not need it .



# break

av = 5

x= int(input("How many candies do you want?"))

i = 1
while i <= x:

    if i >= av:
        print("we are out of stock as we just had " , av , "candies")
        break
        

    print("candy")
    i += 1
    

print("bye")

#continue

for i in range(1,101):
    if i % 3 == 0 or i % 5 == 0:
        pass
    else:
        print(i)

print("bye")



# code to print 
# # # # #
# # # #
# # #
# #
#  




for i in range(5, 0 ,-1):
    print("# " , end = "")
    for j in range(1, i ):
        print("# " , end = "")
        
    print()




# code for printing 
 #1 2 3 4 
 #2 3 4 
 #3 4 
 #4 
  


for i in range(5):
    for j in range(i+1 , 5):
        print(j , end = "")
        


    print()


# code for printing
# APQR 
# ABQR
# ABCR
# ABCD



s1 = 'ABCD'
s2 = 'PQR'
for i in range(4):
    print(s1[0:i+1]+s2[i:])

# more codes 

nums = [23,74,21,67,74]

for num in nums:
    if num%5 == 0:
        print(num)
        break
else:
    print("not found")


x = int(input("enter your number here"))

if x > 1:
    for i in range(2,x):
        if x % i == 0:
            print(x , "is not a prime number")
            break
    else:
        print(x , "is a prime number")
else:
    print(x , "is not a prime number")

# more codes about array

from array import *


vals = array('i', [4,6,7,2,3])
vals.insert(3,9)
vals.reverse()
print(vals)

for i in range(len(vals)):
    print(vals[i])

for i in vals:
    print(i)


newArr = array(vals.typecode,(a for a in vals))

print(newArr)

j = 0
while j < len(newArr):
    print(newArr[j])
    j +=1 


# more about arrays


from array import *

arr = array('i' , [])

n = int(input("enter the length of the array"))


for i in range(n):
    x = int(input("enter the value")) 
    arr.append(x)
    

print(arr)

# functions 



def update(lst):

    print(id(lst))

    lst[1] = 28
    print(id(lst))
    print("x" ,lst)

lst = [10,29,47]
print(id(lst))
update(lst)
print("lst ",lst)

def person(name, age = 19): # formal arguement
    print(name)
    print(age)


person( age = 15,name = "anay" )  # actual arguement
person("musk")


def sum(a,*b):
    c = a

    for i in b:
        c = c + i

    print(c)

sum(5,6 , 54,23)

# also the same programme


def sum(*b):
    c = 0

    for i in b:
        c = c + i

    print(c)

sum(5,6 , 54,23)

def mul(*b):
    c = 1
    
    for i in b:
        c = c * i

    print(c)

mul(5,7,7,9,2,4,65,7,2)


def renew(x):
    print(x)  # takes the value of 'a' as the value of 'x' is given before the print statement of the function
    x = 6
    print(x)  # takes the value of 'x' as it is given within the function after the print statement 


a = 2
renew(a)  # puts / renews the value of 'a' and gives the value of 'x' for the function
print(a)  # prints the original value of 'a'


# keyword variable length arguement 

def person(name , **data):  # double star for printing the keywords as well 

    print(name)
    
    for i,j in data.items():
        print(i,j)



person('anay' , age = 15 , town = 'mollarpur' ,mob = 8347355645)

# global variable and local variable 

a = 10  # global variable
print(id(a))

def something():
    global a # makes the 'a' within the function global . so the 'a' outside the function also takes the value of the local 'a'.
    
    a = 9
    x = globals()['a']  # gives access to all the global variables and change to this value will affect all global values 
    print(id(x))
    print(" in fun", a) 

    globals()['a'] = 15  # the 'a' within function is changed and thus affects all the global 'a'


something()





print(" outside" ,a)

# passing a list to function


def count(lst):

    even = 0 
    odd = 0

    for i in lst:
        if i%2 == 0:
            even += 1
        else:
            odd += 1

    return even , odd



lst = [45,77,23,84,62,76,12,74,79]


even , odd = count(lst)
print(even)
print(odd)

print("even : {} and odd : {}".format(even,odd)) # format gives the formatted style 




# code for selecting some names and then printing which name has letter more than four and which and four or less

def count(name):

    more_than_four = 0
    four = 0
    

    for i in name:
        if len(i) > 4:
            more_than_four += 1
        else:
            four += 1

    return more_than_four ,four

name = ["anay" ," nabin" , "amit" , "arindam" , "debobroto"]

more_than_four , four = count(name)

print(more_than_four)
print(four)

print("more_than_four : {} and four : {}".format(more_than_four,four))


# fibonacci sequence

def fib(n):

    a = 0
    b = 1

    if n == 1:
        print(a)
    elif n <= 0:
        print("negative values are not accepted ")
    else:
        print(a)
        print(b)

        for i in range(2,n):
            
            c = a + b 
            a = b
            b = c
            if c > 100:        # extra . Not needed in the actual fibonacci series
                break          # extra . Not needed in the actual fibonacci series
            else:              # extra . Not needed in the actual fibonacci series
                print(c)       # extra . Not needed in the actual fibonacci series       

fib(int(input("enter the length of the fibonacci sequence")))

# factorial of a number

def fact(n):

    f = 1
    for i in range(1, n + 1):
        f = f * i
    
    return f

x = int(input("enter the number"))
result = fact(x)
print(result)

# recursion


import sys

sys.setrecursionlimit(1743)

print(sys.getrecursionlimit())

i = 0


def greet():
    global i
    i +=1 
    print("hello world", i)
    greet()

greet()

# factorial using recursion

def fact(n):
    if n == 0:
        return 1   

    return n * fact(n - 1)

result = fact(int(input("enter the number whose factorial you want to get")))
print(result)

# basic lambda ( an anonymous function )

f = lambda a,b : a + b
result = f(5,6)
print(result)


# filter , map , reduce

from functools import reduce

nums = [2,4,7,1,7,4,3,2,5,6]

evens = list(filter(lambda n : n % 2 == 0, nums))

doubles = list(map(lambda x : x * 2,evens))

sum = reduce(lambda a , b: a + b , doubles)

print(evens)
print(doubles)
print(sum)

# decoraters in python


def div(a , b):

    print(a/b)

def smart_div(func):

    def inner(a,b):

        if a < b:
            a , b = b , a
        return func(a,b)
    return inner

div1 = smart_div(div)
div1(3,8)

# another example of decoraters

def mul(a,b):
    return(a + b)

def changer(func):
    def inner_changer(a,b):
        if a > b:
            print(a - b)
        else:
            print(a + b)
        return func(a,b)
    return inner_changer

x = changer(mul)
x(6,2)


def div(a,b):
    print(a/b)

def changer(change):
    def inner_changer(a,b):
        print(a*b)
        return change(a,b)
    return inner_changer

x = changer(div)
x(5,6)

# modules in python

# quick remark :: we must save the modules (files) after writting a code to access the code while importing :D



# code in calc.py




def add(a,b):
    return a + b

def sub(a,b):
    return a - b 

def multi(a,b):
    return a*b

def div(a,b):
    return a/b
    
    
# code in demo.py


from calc import *

a = 9
b = 7

c = sub(a,b)

print(c)


# special variable __name__ and __main__



## code in demo.py

import calc


print("demo says " + __name__ )  # the first module __name__ is always main , __name__ is where the code starts as the first point of execution
                                 # this code is printed as usual

## code in calc.py


print("hello" + __name__) # when we are importing calc in demo then the __name__ of calc will print 
                          # the module name ,i.e, 'calc' in demo where the code is run

## code in calc.py


import demo

print("bad morning")  # now the code written in demo.py is not executed as we are importing demo.py as module and we are running the code in calc.py


## code in demo.py

def main():
    print("good morning")


if __name__ == "__main__":  # this ensures that the function is executed only when we execute the code in this file(module) and not in other files(modules)
    main()


## in calc.py

def add():
    print("result 1 is"  __name__)

def sub():
    print("result 2 is")


def main():
    add()
    sub()


if __name__ == "__main__":  # the name variable will have a value main if we are running the code in this module as a stand alone module.
    main()                  # if we are importing the module in any other module then name will print the module name
    
    
## in demo.py

from calc import add

def fun1():
    add()
    print("from fun1")


def fun2():
    print("from fun2")


def main():
    fun1()
    fun2()


main()

# python is a functional programming , procedure oriented programming , object oriented programming 
# class is a design . object is an instance of the design . class can be called blueprint. 


# class

class computer:  # we can put two things in a class : attributes (variables) and behaviour (methods/ functions)

    def config(self): # self is the parameter or arguement of the function
        print("i5, 16 gb ,1 tb ")





com1 = computer()

print(type(com1))

computer.config(com1) # com1 is the value 

com1.config() # config() will take com1 as the parameter or arguement

a = 5 
a.bit_length()


#### more about init variable
# oops binds methods to functions


class computer:

    def __init__(self,cpu,ram):  # init is to initialize the variables . self is arguement that is already being called along with object of the class.
        self.cpu = cpu
        self.ram = ram


    def config(self):
        print("config is " , self.cpu , self.ram)

        

com1 = computer('i3' ,4) # this command wil call the init method for us . we dont need to call init seperately. init wil get called for every object .
com2 = computer('i7' , 8) # here com2 is the value for the self arguement . so while passing arguements to init , we are giving the number of arguements we need along                           # with self. self is one extra arguement .
com1.config()
com2.config()

# another example of use of init variable

class student:

    def __init__(self,maths , science , ssc , computer , hindi):
        self.maths = maths
        self.science = science
        self.ssc = ssc
        self.computer = computer
        self.hindi = hindi

    def marks(self):
        print(self.maths + self.science+ self.ssc + self.computer +self.hindi  )

s1 = student(45,72,64,75,53)
s2 = student(67,91,58,28,62)


s1.marks()
s2.marks()



# code about constructor and self



class computer:
    
    def __init__(self):
        self.name = "anay"
        self.age = 16
 
    def update(self):  # self works as a pointer . it points towards the object based on what is being called . 
                       # self is assigned to the object being called . 
        self.age = 15   
    
    def compare(self,other):  # compare is taking two parameter ... (who is calling , whom to compare)
        if self.age == other.age:
            return True 
        else:
            return False



c1 = computer()  # here c1 is refering to the object of the class computer . it can be called as an instance of the class computer .
c2 = computer()  # here computer() is the constructor . it will call the init method .
c1.age = 20


if c1.compare(c2): # here c1 is self and c2 is other in the function of compare . 
                   # if it was written c2.compare(c1) then c2 would be the self and c1 would be the other.
    print("they are same")  
else:
    print("they are not same") 


print(c1.name)
print(c2.name)
print(c1.age)


# variables in oops

# variables are of two types ... instance variable and class(static) variable
# namespace is an area where we create and store variables . it is of two types ... they are instance namespace and class namespace .


class Car:


    wheels = 4  # if we define a variable outside the init and inside the class , it is a class variable.

    def __init__(self): # mil and car are instance variables
        self.mil = 10
        self.com = "bugatti"

c1 = Car()
c2 = Car()

c1.mil = 8
Car.wheels = 5  # we have to specify the class name as wheel is occupying the class namespace ,i.e, it is a class variable

print(c1.mil, c1.com , c1.wheels)
print(c2.mil, c2.com , c2.wheels)



# some codes with class 

class human:

    legs = 2
    arms = 2
    head = 1

    def __init__(self,confidence, nervousness):
        self.confidence1 = confidence  
        self.nervousness1 = nervousness
        self.confidence = 23
        self.nervousness = 54


anay = human(45,76)
an_idiot = human(23,99)


print(anay.confidence1, anay.nervousness , anay.head)
print(an_idiot.confidence , an_idiot.nervousness1 , an_idiot.arms)

# an example

class computer:

    def config(other):  # it is nor mandatory to give self as the parameter . any other parameter can be given.
        other.ram = 8


com1 = computer()
com1.config()
print(com1.ram)


# another example

class car:

    def __init__(self):  # we dont need to call init
        self.ram = 16
        self.gen = "i7"

ltp1 = car()
print(ltp1.gen)



# more on methods in oops 


# we have three types of methods ... instance methods , class methods , static methods
# instance methods are of two types .. accessor and mutators 
# if we want just fetch the value of the varibles then we will use accessor and if we want to edit then we will use mutators


class student:

    school = "the heritage school"  # here school is class variable / static variable

    def __init__(self ,m1 , m2 , m3):
        self.m1 = m1
        self.m2 = m2
        self.m3 = m3

    def avg(self):  # this is an instance method as we are saying self which denotes that it belongs to an object
        return (self.m1 + self.m2 + self.m3)/3

    def get_m1(self):  # this is an accessor 
        return self.m1

    def set_m1(self,value):  # this is an mutator 
        self.m1 = value

    @classmethod  # a decorater to be used to indicate a class method
    def get_school(cls): #  for instance method we use self keyword and for class methods we use cls keyword
        return cls.school

    @staticmethod
    def info():
        return ("this is student class")

s1 = student(29,72,31)
s2 = student(48,47,23)
print(s1.m1)
print(s1.get_m1())
s1.set_m1(33)
print(s2.avg())
print(s1.m1)


print(student.get_school())  # we dont specify any student . we special all the objects of the class 
print(student.info())


# another example


class anything:

    compulsion = "10 fingers"

    def __init__(self):
        pass

    def marks(self,m1,m2):
        self.m1 = m1
        self.m2 = m2

    def change(self):
        self.m1 = 99
        return self.m1

    def get(self):
        return self.m2

    @classmethod
    def class_method(cls):
        return cls.compulsion

    def static_method():
        print()

s1 = anything()
s2 = anything()

s1.marks(23,65)
s2.marks(54,71)

print(s1.m2 , s1.m1)
print(s2.m2 , s2.m1)
s1.change()
print(s1.m1)
print(s1.get())

print(anything.class_method())


# class inside a class




class Student:  # the object of the inner class should be inside the outer class

    def __init__(self ,name ,rollno):
        self.name = name
        self.rollno = rollno
        self.lap = self.Laptop() # lap is the object of the inner class

    def show(self):
        print(self.name , self.rollno)
        self.lap.show()  # it calls the show method of the laptop class  

    class Laptop:

        def __init__(self):
            self.brand = 'asus'
            self.cpu = 'i7'
            self.ram = 8 

        def show(self):
            print(self.brand , self.cpu , self.ram)

s1 = Student("anay" , 2)
s2 = Student("anita" , 3)

s2.show()

print(s1.lap.brand)

lap1 = s1.lap
lap2 = s2.lap

print(id(lap1))
print(id(lap2))

lap3 = Student.Laptop()
print(lap3.cpu)

s1.show() # executes all the instructions given in the show method of the laptop class




# inheritance 

# single inheritance - when there are two classes A and B and B is inheriting the features of A then we call it as a single level inheritance .
# multi level inheritance - when another class C is there which inherits the features of class B and B is already inheriting the features of A then it is called multi #                           level inheritance .
# multiple inheritance - when class C is inheriting the features of both A and B but B is not inheriting the features of A then it is called multiple inheritance .



class A: 
    def feature1(self):
        print("feature 1 is working")

    def feature2(self):
        print("feature 2 is working")



class B: 
    def feature3(self):
        print("feature 3 is working")

    def feature4(self):
        print("feature 4 is working")

class C(A,B):  
    def feature5(self):
        print("feature 5 is working")

a1 = A()
a1.feature1()
a1.feature2()

b1 = B()
b1.feature2() # there will be an error 

c1 = C()
c1.feature1()

# a simple example of a class inside a class

class programming_langueges:

    def __init__(self, toughness):
        self.toughness = toughness

    class java:

        def __init__(self,difficulty):
            self.difficulty = difficulty



user1 = programming_langueges(454)

print(user1.toughness)

user2 = programming_langueges.java(99)
print(user2.difficulty)

# constructor in inheritance 

class A:

    def __init__(self):
        print("in A init")

    def feature1(self):
        print("feature A is working")
    def feature2(self):
        print("feature 2 is working")

#class B(A):
class B:
    def __init__(self):      # if we create an object of sub class it will first try to find init of sub class 
                             # and if it is not found then it will call init of super class
        
        #super().__init__()
        print("in B init")   

    def feature1(self):
        print("feature B is working")
    def feature4(self):
        print("feature 4 is working")

class C(A,B):
    def __init__(self):
        super().__init__()  # here method resolution order works which means the code execution goes from left to right .
                            # here A is on the left so its code is inherited by C and not the code of B
        print("in C init")

    


a1 = C()
a1.feature1()  # here also mso(method resolution order) works as the code is executed from A as it is in the left hand side


# polymorphism

# polymorphism means many form .. .
# polymorphism is of 4 types - duck typing , operator overloading , method overloading , method overriding


# printing factorial of a number

n = int(input("enter the number"))


j = 1
for i in range(1,n+ 1):
    j = j * i 

print(j)

# duck typing


class VS_code:
    def execute(self):
        print("interpreting")
        print("running")

class My_ide:

    def execute(self):
        print("compiling")
        print("error checking")
        print("interpreting")
        print("running")


class laptop:

    def code(self, ide):  # it does not matter which class's ide (here,object) we are passing , it will still work but we should have same method (here, execute)
                          # it does not matter which class it belongs to . it just should have the same method.
        ide.execute()

ide = VS_code()  # this can work individually
ide = My_ide()   # this can also work individually
lap1 = laptop()
lap1.code(ide)


# operator overloading

# operator overloading simply means that we have the same method but the number of arguements or types of arguements is different 


a = 6
b = 7
c = '453'
d = '42'

print(a + b)

print(int.__add__(a,b))
print(str.__add__(c,d))

# all the operators behind the scene work as methods and are called magic methods

class student:

    def __init__(self,m1,m2):
        self.m1 = m1
        self.m2 = m2

    def __add__(self,other):  # we need to overload the operator
        v1 = self.m1 + self.m2
        v2 = other.m1 + other.m2
        s3 = student(v1,v2)
        return s3

    def __gt__(self,other):
        r1 = self.m1 + self.m2
        r2 = other.m1 + other.m2
        if r1 > r2:
            return True
        else:
            return False
    
    def __str__(self):
        return '{} {} '.format(self.m1 , self.m2)
s1 = student(32,79)
s2 = student(105,62)

s3 = s1 + s2  # behind the scene - student.__add__(s1,s2),,, this is happening
print(s3.m1)

if s1 > s2:
    print("s1 wins")
else:
    print("s2 wins")


a = 9
print(a.__str__())
print(s1) # the inbuild function does not print the value . we have to override the value  
print(s1.__str__())

# an example of duck typing

class A :

    def code (self):
        
        print("nothing really happening")


class B:

    def code(self):

        print("does many things more ")


class C :
    def executable(self,laptop): # the laptop object should be assigned to any class except C (where it is actually)
        laptop.code()

laptop = B()  
s1 = C()  # this should be assigned to the class C as it is going to call the method (executable) of class C
s1.executable(laptop) # here the object is assigned to the method 

# method overloading 
# method overloading means that if in a same class we have two (or more) same methods but the arguements (type or number) is different
# method overloading is not there in python . in python we can't do this 
# for example - student class has two methods named "average" but one of them has 2 arguements while the other has 3 arguements


# method overriding means that if there are two classes (in one class it wont happen) and both the classes have the same name with the same parameter then it is known as method overriding 


# an example of method overloading , it is not directly supported in python so we are doing it indirectly

class student:

    def __init__(self, m1 , m2):
        self.m1 = m1
        self.m2 = m2

    def sum(self , a  = None, b = None , c = None):

        s = 0

        if a!= None and b!= None and c!= None:
            s = a + b + c
        elif a!= None and b!= None:
            s = a + b
        else:
            s = a


        return s


s1 = student(23,71)
print(s1.sum(23,72,98))



# this is method overriding


class A:

    def show(self):
        print("in B show")

class B(A):

    def show(self):  # this show method overrides the show method of its parent class(A)
        print("in B show")


a1 = B()
a1.show()



# an example


class python:

    def __init__(slef, m1,m2): # an example to show that instead of self we can also take slef,i.e, we can take any arguement name
        slef.m1 = m1
        slef.m2 = m2


s1 = python(34,65)
print(s1.m1)


# abstract classes 


# python does not by default support abstract classes but we can use a module named 'ABC' to use abstract classes 
# 'ABC' stands for Abstract Base Classes
# we cant create objects of abstract classes 

from abc import ABC , abstractclassmethod, abstractmethod


class computer(ABC):
    @abstractmethod  # this is a decorator 
    def process(self):
        print("running") # this is the body
                         # is this print statement wasn't there then we had to say 'pass' command to declare that we have no code here. such a method which has 
                         # relation but not a definition is called abstract methods . the class containing the abstract method(at least one) is called abstract                                # classes 

class laptop(computer): # laptop class is inheriting an abstract class , so we need to define the abstract method otherwise this will also be an abstract class 
    def process(self):
        print("its running")

class programmer:
    def work(self,com1):
        print('solving bugs')
        com1.process()

class whiteboard(computer):  # if whiteboard didnot inherit the computer class then there would be no compulsion to have the abstract method of the abstract class
    def write(self):         # but as we have written ' whiteboard(computer) ' so we have to define the abstract method of the abstract class computer ,i.e, process
        print("its writing")



#com1 = computer()
#com1.process()
com2 = laptop()
#com2.process()
com3 = whiteboard()
prog1 = programmer()
prog1.work(com3)


# iterator 


nums = [3,6,2,7]

it = iter(nums)

print(it.__next__())

print(next(it))

for i in nums:
    print(i)
    
    
    
    
# way to build our own iterator . we need two methods , iter() and next()
# iter() will give the objects of the iterator and next() will give the next element



class top_ten:

    def __init__(self):
        self.num = 1

    def __iter__(self):
        return self

    def __next__(self):

        if self.num <= 10:
            val = self.num
            self.num += 1 
            return val
        else:
            raise StopIteration  # this is way to stop the for loop here as there are no specific limit given to the for loop. we need to raise an execption

values = top_ten()

print(values.__next__())  
print(next(values))        
for i in values:           # it seems like iterator will print the value 3 times due to the previous two print statements but it doesn't . 
    print(i)               # since we got the values of 1 and 2 due to the previous two print statements ,it does not procees further to print 1 and 2 again.


# generators 


def topten():
 
    yield 5  # as we are using yield so this function is a generator now . 
    yield 4  # we can write multiple yield statements but we cant write multiple return statements as the first return wil be taken 
    yield 6
    yield 7
    


values = topten()
print(values.__next__())
print(values.__next__())
print(next(values))

for i in values:
    print(i)

# example to show that we cant write multiple return statements 

def personal_use():

    return 6
    return 7
    return 8


print(personal_use())

# for loop is an iterator 
# generators will give iterators 

def topten():

    n = 1

    while n <= 10:
        sq = n*n
        yield sq
        n += 1


values = topten()

for i in values:

    print(i)

# an example of generator and an innovative way to print the odd numbers less than the given value(here, 10)

def generators():

    i = 1
    print(i)
    while i <= 10:
        i = i + 2
        yield i 
        

    
test_try = generators()
for i in test_try:
    print(i)



# errors in python 

# syntactical errors - this can be called compile time errors .suppose we are forgetting to put a (:) after if statement 
#                      then this can be called syntactical error or compile time error 

# logical error - the code will be compiled , the code will run , we will get an output , but we will get a wrong output 

# run time error - the code is working but somewhere between the code execution we are getting an error .  
#                  for e.g. - if we input 6/0 then it will give us an error . this is run time error. 
#                  this is an user input error .

# normal statement are those which will not give us error
# critical statement are those which can give us error





a = 5  # normal statement
b = 2  # normal statement 

try:
    print("resource open")
    print(a/b)  # critical statement 
    k = int(input('enter a number'))
    print(k)
    
except ZeroDivisionError as e:
    print("hey , you cannot divide a number by zero :", e)

except ValueError as e:
    print("invalid input")


except Exception as e: # this will only run when we have an error   # this handles all the other errors
    print("something went wrong")

    
finally:  # this will run irrespective of the statement has exception or not  
    print("resource close")
    
    
    
    
# thread - it can be called a light weight process
# every execution has one thread by default .  that is the main thread 

# creation of threads

from time import sleep 
from threading import *


class hello(Thread):
    def run(self):
        for i in range(5):
            print("hello")
            sleep(1)


class hi(Thread):
    def run(self):
        for i in range(5):
            print("hi")
            sleep(1)


t1 = hello()
t2 = hi()

t1.start()  # instead of calling run() we have to call start() . this is because start wil internally call a mehtod called run()
            # so , in both the classes we have defined run method as it is there in Thread class . other methods wont work there .
sleep(0.2)    # this command ensures gap between two executions
t2.start()  

t1.join()  # this asks the main thread to wait for t1 and t2 to be executed and then it executes bye 
t2.join()

print("bye") # this is executed by the main thread 


## PYTHON - INTERPRETED OR COMPILED ?

# compiler can convert any languege to any languege 
# interpreter executes the code line by line 

# when we write a code (so called, source code) in python , it first gets compiled to a byte code.
# then it is interpreted to machine languege , by a virtual machine 

# virtual machine software ensures that the byte code runs on any cpu irrespective of there architectures 
# if we have a vm(virtual machine) software then we are good to go .
# this vm is specific for every langueges . python is run on pvm.

# whatever we code gets converted in byte code and then it is interpreted by a vm ( for python , pvm)

# so , python is both compiled and interpreted languege .
# behind the scene , our code gets compiled and interpreted .


# an example of multi threading 

from threading import Thread
from time import *


class A(Thread):
    def run(self):
        for i in range(5):
            print("interpreting")
            sleep(1)

class B(Thread):
    def run(self):
        for i in range(4):
            print("compiling")
            sleep(1)

code1 = A()
code2 = B()

code1.start()
sleep(0.2)
code2.start()

code1.join()
print("job done")
code2.join()  # even if we had placed this statement before print("job done") then also it would have given the same result


# an example of abstract classes 

from abc import  ABC , abstractmethod


class coding(ABC):
    @abstractmethod
    def code(self):
        print("compiling")

code1 = coding()
code1.code()



# linear search

pos = -1


def search(list,n):
    i = 0

    while i < len(list):
        if list[i] == n:
            globals()['pos'] = i
            return True
        i += 1
        
    return False



list = [4,5,6,3,7]

n = int(input("enter the number you are searching for "))

if search(list,n):
    print("found at place of" , pos + 1)
else:
    print("not found")


# linear search with for loop


pos = 0


def search(list,n):
    

    for i in range(len(list)):  # for loop uses a range , while loop does not uses range because for loop is an iterator 
        if list[i] == n:
            globals()['pos'] = i
            return True
        
        
    return False



list = [4,5,6,3,7]

n = int(input("enter the number you are searching for "))

if search(list,n):
    print("found at place of" , pos + 1)
else:
    print("not found")


# binary search
# the values should be sorted


pos = -1 


def search(list, n):

    l = 0
    u = len(list) - 1

    while l <= u:
        mid = (l + u)// 2

        if list[mid] == n:
            globals()['pos'] = mid
            return True
        else:
            if list[mid] < n:
                l = mid + 1
            else:
                u = mid - 1

    return False

list = [3,21,25,74,89,92]
n = int(input("enter the number you are searching for"))

if search(list,n):
    print("found at", pos + 1)
else:
    print("not found")


# binary search with for loop


# in binary search we have to take the first value as l and the last value as u . then we have to take out the mid point(as index number) of l and u
# then we have to check that if the mid point is matching with the given value . if it is matching then we will have the desired result .
# if it is not matching then we have to check whether the given input is less than or greater than n . if it less than n then we have to 
# increase the lower limit by 1, if it is greater than n then we have to lower the u . the loop checks for the values if it is matching 
# with the given value . it changes the l or the u and then again finds the mid point of the two new values. 
# the process keeps repeatating



list = [3,6,23,77,89,95]

n = int(input("enter the number you want to search"))


l = 0
u = len(list) - 1  
for i in range(len(list)-1):

    mid = (l + u)// 2

    if list[mid] == n:
        print("found at" , mid + 1)
        break
    else:
        if  list[mid]<n:
            l = mid + 1
        else:
            u = mid - 1
else:
    print("not found")




# bubble sorting

# swaping is an important concept in sorting 

def sort(nums):
    for i in range(len(nums)-1 , 0 , -1): # this loop is for iterating the inner loop for the required number of times
        for j in range(i):  # this internal loop is to do the function of swapping
            if nums[j] > nums[j + 1]:
                temp = nums[j]
                nums[j] = nums[j + 1]
                nums[j + 1] = temp



nums = [5,3,8,6,7,2]
sort(nums)
print(nums)



# a practice of bubble sorting 

def sorter(n):
    for i in range(len(nums)-1 , 0 , -1):
        for j in range(i):
            if nums[j] > nums[j + 1]:
                # vary = nums[j]
                # nums[j] = nums[j + 1]
                # nums[j + 1] = vary
                nums[j] , nums[j + 1] = nums[j + 1] , nums[j]   # this can also be used in python to swap
    print(nums)




nums = [32,54,123,8787,1234,6263,211]
sorter(nums)




# selective sorting
# this is better than bubble sorting as this involves swapping only once during every iteration 
# in bubble sorting multiple times swapping is done in each iteration


def sort(nums):

    for i in range(len(nums)- 1):  # also applicable ----> range(len(nums))
        minpos = i
        for j in range(i,len(nums)):
            if nums[j] < nums[minpos]:
                minpos = j

        # nums[minpos] , nums[i] = nums[i] , nums[minpos]    # also applicable instead of the following statements
        temp = nums[minpos]
        nums[minpos] = nums[i]
        nums[i] = temp

        print(nums)


nums = [5,7,2,8,9,3]

sort(nums)
print(nums)

# another example


def sort(list_nums):

    for i in range(len(list_nums)):
        minval = i
        for j in range(i,len(list_nums)):
            if list_nums[j] < list_nums[minval]:
                minval = j

        list_nums[i] , list_nums[minval] = list_nums[minval] , list_nums[i]

        print(list_nums)

list_nums = [54,29,60,86,2,27,26,6,88,24,21,76,7,67,]
sort(list_nums)
print(list_nums)



# special fibonacci sequence 



n = int(input("enter the number of terms"))

a = 0
b = 1
print(a, "+", end ="")
print(b, "+", end ="")
j = 1

for i in range(n-2):
    c = a + b
    a = b
    b = c
    
    if i == n -3:
        print(b, end = "")
    else:
        print(b, "+", end ="")

    j += b
print( "=", j)


# some practice of coding 

#dictionary_practice

from webbrowser import get


numbers = {"name" : "anay" , "address": "mallarpur" , "mobileno." : 5636544865}
print(numbers.get("address","not there"))
numbers["name"] = "jack"
print(numbers)
keys = ["fav_sub" , "worst_sub"]
values = ["technology" , "languege"]
numbers2 = dict(zip(keys, values))
print(numbers2)
print(numbers["mobileno."])

#list_practice

num = [2,3,6,8,1,7]
print(num[1])
if num[2] == 0:
    print("No")
else:
    print("Yes")
num[1] = "anay"
print(num)
num[3] = "wow!"
print(num)
num[2] = num[3]
print(num)
for i in range(len(num)):
    print(num[i])
for i in range(len(num)):
    num[i-1] = num[i]
print(num)



# code to print the sum of digits of numbers 

n = int(input("enter a number"))
s = 0

while n > 0:
    digit = n % 10
    s += digit
    n = n // 10

print(s)


# there is a difference between 'is' and '=='  . 'is' says that both belongs to the same address. 
# '==' says that both just contains the same value and doesn't say anything about the same address. 


# usage of random function to print as many random numbers as many we want,i.e , as many as the user wants

import random

n = int(input("enter the range till which you want a random number"))
a = int(input("how many numbers do you want?"))

def randomize():
    for i in range(a):
        m = random.randrange(n)
        print(m)
        i += 1


randomize()



# code to print a given number in words 




# Function to return the word
# of the corresponding digit
def printValue(digit):

	# Switch block to check for each digit c

	# For digit 0
	if digit == '0':
		print("Zero ", end = " ")

	# For digit 1
	elif digit == '1':
		print("One ", end = " ")

	# For digit 2
	elif digit == '2':
		print("Two ", end = " ")

	#For digit 3
	elif digit=='3':
		print("Three",end=" ")

	# For digit 4
	elif digit == '4':
		print("Four ", end = " ")

	# For digit 5
	elif digit == '5':
		print("Five ", end = " ")

	# For digit 6
	elif digit == '6':
		print("Six ", end = " ")

	# For digit 7
	elif digit == '7':
		print("Seven", end = " ")

	# For digit 8
	elif digit == '8':
		print("Eight", end = " ")

	# For digit 9
	elif digit == '9':
		print("Nine ", end = " ")

# Function to iterate through every
# digit in the given number
def printWord(N):
	i = 0
	length = len(N)

	# Finding each digit of the number
	while i < length:
		
		# Print the digit in words
		printValue(N[i])
		i += 1

# Driver code
N = input("enter a number")
printWord(N)


//LENGTH OF THE CHAR ARRAY

#include<iostream>
using namespace std;

int getlength(char num[]){
    int count = 0;
    for (int i = 0;num[i] != '\0';i++){
        count++;
    }
    return count;
}

int main(){
    char ch[20];

    cout<<"enter the name"<<endl;
    cin>>ch;

    cout<<"the length of the array is "<<getlength(ch);
}

//REVERSE OF THE CHAR ARRAY

#include<iostream>
using namespace std;

void reversearray(char num[],int n){
    int start = 0;
    int end = n - 1;
    while(start<end){
        swap(num[start++],num[end--]);
    }
}

int getlength(char num[]){
    int count = 0;
    for (int i = 0;num[i] != '\0';i++){
        count++;
    }
    return count;
}


int main(){
    char ch[20];

    cout<<"enter the name"<<endl;
    cin>>ch;
    int len = getlength(ch);
    cout<<"the reverse of the array is";
    reversearray(ch,len);
    cout<<"the name is";
    cout<<ch;
}


//FIBONACCI SERIES USING RECURSION

#include<iostream>
using namespace std;

int fib(int n){
    if(n==0){
        return 0;
    }
    if(n==1){
        return 1;
    }

    int ans = fib(n - 1) + fib(n - 2);
    return ans;

}

int main(){
    int n;
    cin>>n;
    cout<<fib(n);
}
