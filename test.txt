

welcome to my first code in github

#selective sorting

def sort(nums):
    
    for i in range(len(nums)):
        minval = i 
        for j in range(i,len(nums)):
            if nums[j]<nums[minval]:
                minval = j

        temp = nums[i]
        nums[i]= nums[minval]
        nums[minval] = temp


nums = [5,3,8,6,7,2]
sort(nums)

print(nums)
 

#bubble sorting

def sort(nums):
    for i in range(len(nums)- 1 , 0 , -1):
        for j in range(i):
            if nums[j]> nums[j+1]:
                temp = nums[j]
                nums[j]= nums[j+1]
                nums[j+1]= temp


nums = [5,2,6,8,9,4]
sort(nums)
print(nums)


#this is a calculator

def add(a,b):
    result = a + b 
    print(result)

def sub(a,b):
    result = a - b
    print(result)

def mul(a,b):
    result = a * b 
    print(result)

def div(a,b):
    result = a / b 
    print(result)

a = int(input("enter the first number:"))
b = int(input("enter the second number:"))
op = input("enter the operator:")

if op == "+":
    add(a,b)
elif op == "-":
    sub(a,b)
elif op == "*":
    mul (a,b)
elif op == "/":
    div(a,b)
else:
    print("invalid operator")
    
    
#this is a countdown timer 

import time

def countdown(t):

    while t:
        mins , secs =  divmod( t , 60)
        timer = '{:02d} : {:02d}' . format(mins , secs)
        print(timer )
        time.sleep(1)
        t -= 1

    print("you are killed")

t = int(input("enter the number of seconds"))
countdown(int(t))

#clock

from tkinter import *
from tkinter.ttk import *
from time import strftime

root = Tk()
root.title("clock")

def time():
    string = strftime('%H:%M:%S %p')
    label.config(text=string)
    label.after(1000, time)

label = Label(root , font=("western_bang_bang" , 50) , background= "black", foreground = "cyan")
label.pack(anchor="center")
time()

mainloop()

#hangman 

import random

with open('words.txt', 'r') as f:
    words = f.readlines()

word = random.choice(words)[:-1]

allowed_errors = 7 
guesses =[]
done = False

while not done:
    for letter in word :
        if letter.lower() in guesses:
            print(letter, end=" ")
        else:
            print("_", end=" ")
    print("")
    

    guess = input(f"Allowed_errors left{allowed_errors}, Next guess:")
    guesses.append(guess.lower())
    if guess.lower() not in word.lower():
        allowed_errors -= 1
        if allowed_errors == 0:
            break

    done = True
    for letter in word:
        if letter.lower() not in guesses:
            done = False

if done:
    print(f"you found the word! it was {word}")
else:
    print(f"game over! the word was {word}")
    
    
    
#snake game made 


import random
import pygame
import time

from pygame.constants import WINDOWHITTEST

pygame.init()


white = (255, 255 , 255)
black = (0, 0, 0)
red = (255 ,0 , 0 )
orange = (255 , 165 , 0)


width, height = 600 , 400


game_display = pygame.display.set_mode((width , height))
pygame.display.set_caption("anay's snake game")

clock = pygame.time.Clock()

snake_size = 10
snake_speed = 10

message_font = pygame.font.SysFont('ubuntu' , 30)
score_font = pygame.font.SysFont('ubuntu' , 25)

def print_score(score):
    text = score_font.render("Score:" + str(score), True , orange)
    game_display.blit(text, [0,0])

def draw_snake(snake_size, snake_pixels):
    for pixels in snake_pixels:
        pygame.draw.rect(game_display, white , [pixels[0], pixels[1] , snake_size , snake_size])

def run_game():


    game_over = False
    game_close = False

    x = width / 2
    y = height / 2 

    x_speed = 0
    y_speed = 0

    snake_pixels =[]
    snake_length = 1

    target_x = round(random.randrange(0, width -snake_size) / 10.0) * 10.0
    target_y = round(random.randrange(0, height -snake_size) / 10.0) * 10.0

    while not game_over:

        while game_close:
            game_display.fill(black)
            game_over_message = message_font.render("game over!" , True , red)
            game_display.blit(game_over_message, [width / 3 , height / 3 ])
            print_score(snake_length - 1 )
            pygame.display.update()

            for event in pygame.event.get():
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_1:
                        game_over = True
                        game_close = False
                    if event.key == pygame.K_2:
                        run_game()
                if event.type == pygame.QUIT:
                    game_over = True
                    game_close = False                    

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                game_over = True
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_LEFT:
                    x_speed = -snake_size
                    y_speed = 0
                if event.key == pygame.K_RIGHT:
                    x_speed = snake_size
                    y_speed = 0 
                if event.key == pygame.K_UP:
                    x_speed = 0
                    y_speed = -snake_size
                if event.key == pygame.K_DOWN:
                    x_speed = 0
                    y_speed = snake_size

        if x>= width or x < 0 or y>=height or y < 0 :
            game_close = True

        x += x_speed 
        y += y_speed


        game_display.fill(black)
        pygame.draw.rect(game_display , orange , [target_x, target_y, snake_size, snake_size])

        snake_pixels.append([x,y])

        if len(snake_pixels) > snake_length :
            del snake_pixels[0]

        for pixels in snake_pixels[:-1]:
            if pixels == [x,y]:
                game_close = True

        draw_snake(snake_size, snake_pixels)
        print_score(snake_length - 1)

        pygame.display.update()

        if x == target_x and y == target_y:
            target_x = round(random.randrange(0, width -snake_size) / 10.0) * 10.0
            target_y = round(random.randrange(0, height -snake_size) / 10.0) * 10.0
            snake_length += 1

        clock.tick(snake_speed)

    pygame.quit()
    quit()

run_game()

#flappybird game made

import pygame
import neat
import time
import os
import random
pygame.font.init()

WIN_WIDTH = 700
WIN_HEIGHT = 700

BIRD_IMGS = [pygame.transform.scale2x(pygame.image.load(os.path.join("imgs", "bird1.png"))), pygame.transform.scale2x(pygame.image.load(os.path.join("imgs", "bird2.png"))), pygame.transform.scale2x(pygame.image.load(os.path.join("imgs", "bird3.png")))]
PIPE_IMG = pygame.transform.scale2x(pygame.image.load(os.path.join("imgs", "pipe.png")))
BASE_IMG = pygame.transform.scale2x(pygame.image.load(os.path.join("imgs", "base.png")))
BG_IMG = pygame.transform.scale2x(pygame.image.load(os.path.join("imgs", "bg.png")))

STAT_FONT = pygame.font.SysFont("DejaVu Sans" , 50)

class Bird:
    IMGS = BIRD_IMGS
    MAX_ROTATION = 25
    ROT_VEL = 20
    ANIMATION_TIME = 5

    def __init__(self , x , y):
        self.x = x
        self.y = y 
        self.tilt = 0 
        self.tick_count = 0
        self.vel = 0
        self.height = self.y
        self.img_count = 0
        self.img = self.IMGS[0]

    def jump(self):
        self.vel = -10.5
        self.tick_count = 0
        self.height = self.y

    def move(self):
        self.tick_count += 1

        d = self.vel*self.tick_count + 1.5*self.tick_count**2

        if d >= 16:
            d = 16

        if d < 0:
            d -= 2

        self.y = self.y + d

        if d < 0 or self.y < self.height + 50:
            if self.tilt < self.MAX_ROTATION:
                self.tilt = self.MAX_ROTATION
            else:
                if self.tilt > -90:
                    self.tilt -= self.ROT_VEL

    def draw(self , win):
        self.img_count += 1

        if self.img_count < self.ANIMATION_TIME:
            self.img = self.IMGS[0]
        elif self.img_count < self.ANIMATION_TIME*2:
            self.img = self.IMGS[1]
        elif self.img_count < self.ANIMATION_TIME*3:
            self.img = self.IMGS[2]
        elif self.img_count < self.ANIMATION_TIME*4:
            self.img = self.IMGS[1]
        elif self.img_count == self.ANIMATION_TIME*4 + 1:
            self.img = self.IMGS[0]
            self.img_count = 0

        if self.tilt <= -80:
            self.img = self.IMGS[1]
            self.img_count = self.ANIMATION_TIME*2

        rotated_image = pygame.transform.rotate(self.img , self.tilt)
        new_rect = rotated_image.get_rect(center=self.img.get_rect(topleft = (self.x , self.y)).center)
        win.blit(rotated_image , new_rect.topleft)

    def get_mask(self):
        return pygame.mask.from_surface(self.img)

class Pipe:
    GAP = 200
    VEL = 5
    
    def __init__(self , x):
        self.x = x
        self.height = 0
        

        self.top = 0
        self.bottom = 0
        self.PIPE_TOP = pygame.transform.flip(PIPE_IMG , False , True)
        self.PIPE_BOTTOM = PIPE_IMG

        self.passed = False
        self.set_height()

    def set_height(self):
        self.height = random.randrange(50 , 450)
        self.top = self.height - self.PIPE_TOP.get_height()
        self.bottom = self.height + self.GAP

    def move(self):
        self.x -= self.VEL

    def draw(self , win):
        win.blit(self.PIPE_TOP , (self.x , self.top))
        win.blit(self.PIPE_BOTTOM, (self.x, self.bottom))

    def collide(self , bird):
        bird_mask = bird.get_mask()
        top_mask =  pygame.mask.from_surface(self.PIPE_TOP)
        bottom_mask =  pygame.mask.from_surface(self.PIPE_BOTTOM)

        top_offset = (self.x - bird.x , self.top - round(bird.y))
        bottom_offset = (self.x - bird.x , self.bottom - round(bird.y))

        b_point = bird_mask.overlap(bottom_mask , bottom_offset)
        t_point = bird_mask.overlap(top_mask , top_offset)

        if t_point or b_point:
            return True

        return False
        
class Base:
    VEL = 5
    WIDTH = BASE_IMG.get_width()
    IMG = BASE_IMG

    def __init__(self, y):
        self.y = y 
        self.x1 = 0
        self.x2 = self.WIDTH

    def move(self):
        self.x1 -= self.VEL
        self.x2 -= self.VEL

        if self.x1 + self.WIDTH < 0:
            self.x1 = self.x2 + self.WIDTH

        if self.x2 + self.WIDTH < 0:
            self.x2 = self.x1 + self.WIDTH

    def draw(self , win):
        win.blit(self.IMG , (self.x1 , self.y))
        win.blit(self.IMG , (self.x2 , self.y))

def draw_window(win , birds , pipes, base , score):
    win.blit(BG_IMG , (0,0))

    for pipe in pipes:
        pipe.draw(win)

    text = STAT_FONT.render("Score" + str(score), 1, (255,255,255))
    win.blit(text , (WIN_WIDTH - 10 - text.get_width() , 10))


    base.draw(win)

    for bird in birds:
        bird.draw(win)

    pygame.display.update()

def main(genomes , config):
    nets = []
    ge = []
    birds = []

    for _, g in genomes:
        net = neat.nn.FeedForwardNetwork.create(g , config)
        nets.append
        birds.append(Bird(230 , 350))
        g.fitness = 0
        ge.append(g)


    base = Base(730)
    pipes = [Pipe(600)]
    win = pygame.display.set_mode((WIN_WIDTH , WIN_HEIGHT))
    clock = pygame.time.Clock()

    score = 0 

    run = True
    while run:
        clock.tick(30)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False
                pygame.quit()
                quit()


        pipe_ind = 0
        if len(birds) > 0:
            if len(pipes) > 1 and birds[0].x > pipes[0].x + pipes[0].PIPE_TOP.get_width():
                pipe_ind = 1
        else:
            run = False
            break


        for x , bird in enumerate(birds):
            bird.move()
            ge[x].fitness += 0.1

            output = nets[x].activate((bird.y , abs(bird.y - pipes[pipe_ind].height) , abs(bird.y - pipes[pipe_ind].bottom)))

            if output[0] > 0.5:
                bird.jump()


        add_pipe = False
        rem = []
        base.move()
        for pipe in pipes:
            for x, bird in enumerate(birds):
                if pipe.collide(bird):
                    ge[x].fitness -= 1
                    birds.pop(x)
                    nets.pop(x)
                    ge.pop(x)
                       
            
                if not pipe.passed and pipe.x < bird.x:
                    pipe.passed = True
                    add_pipe = True

            if pipe.x + pipe.PIPE_TOP.get_width() < 0:
                rem.append(pipe)

            pipe.move()   

        if add_pipe:
            score += 1
            for g in ge:
                g.fitness += 5
            pipes.append(Pipe(600))
        
        for r in rem:
            pipes.remove(r)

        for bird in birds:
            if bird.y + bird.img.get_height() >= 730 or bird.y < 0:
                birds.pop(x)
                nets.pop(x)
                ge.pop(x)
                
        
        base.move()
        draw_window(win , birds , pipes , base , score)


def run(config_path):
    config = neat.config.Config(neat.DefaultGenome , neat.DefaultReproduction , 
                     neat.DefaultSpeciesSet , neat.DefaultStagnation ,
                     config_path)

    p = neat.Population(config)

    p.add_reporter(neat.StdOutReporter(True))
    stats = neat.StatisticsReporter()
    p.add_reporter(stats)

    winner = p.run(main, 50)

if __name__ == "__main__":
    local_dir = os.path.dirname(__file__)
    config_path = os.path.join(local_dir , "config-feedforward.txt")
    run(config_path)



# for printing  : anay's "laptop"

print('anay\'s "laptop"')


# simple codes 

num = [23 , 45  , 73 , 47 , 67]

num.append(44)
num.remove(23)
num.insert(3 , 99)
num.pop(2)
num.extend([22 , 76, 56, 41 , 11])
del num[3:]

print(num)

################









            


    



