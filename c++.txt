welcome to c++ codes

#####################################################################################
DATATYPES

#include<iostream>
using namespace std;

int main() {

/*
    int a = 1223;
    cout<< a << endl;
    char b = 'v';
    cout<< b <<endl;
    float f = 1.2;
    cout<< f;
*/
}

#####################################################################################
OPERATORS
#include<iostream>
using namespace std;

int main() {

    int a = 2/5;
    cout<< a<< endl;

    int b = 2.0/5;
    cout<< b <<endl;

    cout << 2.0/5;
    
}


######################################################################################
LOOPS

#include<iostream>
using namespace std;

int main() {

    int a;   //to consider a interger 'a'
    cin >> a;
    cout<< "the number is:" << a << endl;
 
}

#include<iostream>
using namespace std;

int main() {

    int a;
    cin >> a;
    if(a>0) {
        cout<<"a is positive" <<endl;   
    }
    else {
        cout<< "a is negative" << endl;
    }    
 
}


**display values

#include<iostream>
using namespace std;

int main() {

    int a,b;
    cin >> a >> b;
    cout<<"value of a and b are " << a << " and "<< b << endl;
}

*** conditions
#include<iostream>
using namespace std;

int main() {

    int a;
    cout <<" enter the value of a";
    cin >> a;
    if (a>0){
        cout<< "a is negative";
    }
    else{
        if (a<0){
            cout<< "a is positive";
        }
        else{
            cout<<"a is 0";
        }
    }   
    
 
}

#include<iostream>
using namespace std;

int main() {

    int a;
    cout <<" enter the value of a";
    cin >> a;
    if (a>0){
        cout<< "a is negative";
    }
    else if(a<0) {
        cout<< "a is positive";
        
    }
   
 
}


######### WHILE LOOP
#include<iostream>
using namespace std;

int main() {

    int n;
    cin>>n;
    int i =1;

    while (i<=n){
        cout<<i<<" ";
        i = i + 1;
    }   
 
}


#include<iostream>
using namespace std;

int main() {

    int n;
    cin >> n;

    int i = 1;
    int sum = 0;

    while (i<=n){
        sum = sum + i;
        i = i + 1;
    }

    cout<< "the answer is " << sum <<endl;    
   
 
}


*****PRIME NUMBER
#include<iostream>
using namespace std;

int main(){
    int n;
    cin >> n;

    int i = 2;

    while(i<n) {
        if(n%i==0) {
            cout << "not prime "<< i << endl;
        }
        else{
            cout<< "prime for" << i << endl;
        }
        
        i = i + 1;
    }
}


######################################################################################
PATTERNS

/*

* * * *
* * * *
* * * *
* * * *

*/



#include<iostream>
using namespace std;

int main(){
    int n;
    cin >> n;

    int i = 1;
    while (i<=n){
        int j = 1;
        while (j<=n){
            cout<<"*";
            j = j + 1;

        }
        cout<<endl;

        i = i + 1;
    }
    
}


/*
1 1 1 
2 2 2
3 3 3


*/

#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int i = 1;
    while (i<=n) {
        int j = 1;
        while (j<=n){
            cout<< i ;
            j = j + 1;
        }
        cout << endl;
        i = i + 1;

    }
}


/*
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
*/

#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int i = 1;
    while (i<=n) {
        int j = 1;
        while (j<=n){
            cout<< j ;
            j = j + 1;
        }
        cout << endl;
        i = i + 1;

    }
    
}



/*
4 3 2 1
4 3 2 1
4 3 2 1
4 3 2 1
*/

#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int i = 1;
    while (i<=n) {
        int j = 1;
        while (j<=n){
            cout<< n-j+1 ;
            j = j + 1;
        }
        cout << endl;
        i = i + 1;

    }
    
}


/*
1 2 3
4 5 6
7 8 9
*/

#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int i = 1;
    int count = 1;
    while (i<=n) {
        
        int j = 1;
        while (j<=n){  // number of stars depending on row number
                cout<<count<< " ";
                j = j + 1;
                count = count + 1;
        }
        cout<<endl;
        i = i + 1;
        

    }
    
}


/*
*
* *
* * *
*/

#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int i = 1;
    
    while (i<=n) {
        
        int j = 1;
        while (j<=i){
                cout<<"*"<< " ";
                j = j + 1;
                
        }
        cout<<endl;
        i = i + 1;
        

    }
    
}


/*
1
2 3
3 4 5
4 5 6 7
*/

#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int i = 1;
    
    
    while (i<=n) {
        int count = i;
        int j = 1;
        while (j<=i){
                cout<<count<< " ";
                j = j + 1;
                count = count + 1;
                
        }
        cout<<endl;
        i = i + 1;
        

    }
    
}


/*
A A A 
B B B 
C C C
*/

#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int i = 1;
    while (i<=n){
        int j = 1;
        while (j<=n){
            char ch = 'A' + i - 1;
            cout<<ch;
            j = j +1;


        }
        cout<<endl;
        i = i + 1;
    }   

    
    
}



/*
A B C
A B C
A B C
*/

#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int i = 1;
    while (i<=n){
        int j = 1;
        while (j<=n){
            char ch = 'A' + j - 1;
            cout<<ch;
            j = j +1;


        }
        cout<<endl;
        i = i + 1;
    }   

    
    
}



/*
A 
B C
C D E 
D E F G
*/

#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int i = 1;
    while (i<=n){
        int j = 1;
        while (j<=i){
            char ch = 'A' + i + j - 2;
            cout<<ch;
            j = j + 1;
        }
        cout<<endl;
        i = i + 1;
    }   
    
}


/*
D
C D
B C D
A B C D
*/

#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int i = 1;
    while (i<=n){
        int j = 1;
        while (j<=i){
            char ch = 'D' + j - i;
            cout<<ch<< " ";
            j = j + 1;
        }
        cout<<endl;
        i = i + 1;
    }   
    
}


/*
   *
  **
 ***
****
*/

#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    
    int i = 1;
    while (i<=n){
        // space print karlo
        int space = n - i;
        while (space){
            cout<<" ";
            space = space -1;
        }
        // star print karlo
        int j = 1;
        while (j<=i){
            cout<<"*";
            j = j + 1;
        }
        cout<<endl;
        i = i +1;


    }   
       
    
}


/*
****
 ***
  **
   *
*/

#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    
    int i = 1;
    while (i<=n){
        
        int space = 1;
        while (space<=i){ 
            cout<<" ";
            space = space +1;
        }
        
        int j = n-i+1;
        while (j){
            cout<<"*";
            j = j -1;
        }
        cout<<endl;
        i = i +1;


    }   
       
    
}


/*
   1
  121
 12321
1234321
*/

#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int i = 1;
    while (i<=n){
        //print space
        int space = n - i;
        while (space){
            cout<<" ";
            space = space - 1;

        }



        //print 1st triangle
        int j = 1;
        while (j<=i){
            cout<<j;
            j = j + 1;
        }


        //print 2nd triangle
        int start = i -1;
        while (start){
            cout<<start;
            start = start - 1;

        }
        cout<<endl;
        i = i + 1;
    }
    
}


####################################################################
FOR LOOP

#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    
    for( int i= 1;i<=n ;i++ ){
        cout<<i<<endl;
        
        

    }       
}

#include<iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int i = 1;
    for( ; ; ){
        if (i<=n){
            cout<<i<<endl;
        }
        else{
            break;
        }
        i++;

    }
    
    
}


// FIBONACCI SERIES

#include<iostream>
using namespace std;

int main() {
    int n = 10;
    int a = 0;
    int b = 1;

    for (int i=1; i<=n; i++ ){
        int nextnumber = a + b;
        cout<<nextnumber<< " ";
        a = b;
        b = nextnumber;
    }
    
    
    
    
}


// sum of digits
#include<iostream>
using namespace std;

int main() {
    int n;
    cin>>n;
    int sum = 0;
    while(n!=0){
        int digits = n % 10;
        sum = sum + digits;
        n = n / 10;
    }
    cout<<sum;
    
}



//reversal of digits(reverse integer)
#include<iostream>
using namespace std;

int main() {
    int n ;
    cin >> n;
    int ans = 0;
    while(n!=0){
        int digit = n % 10;
        n = n /10;
        ans = ans*10 + digit;

    }
    cout << ans;
    
}


#########################################
SWITCH CASE

#include<iostream>
using namespace std;

int main() {

    int num = 2;

    switch(num){
        case 1: cout<<"first"<<endl;
                break;
        case 2: cout<<"second"<<endl;
                break;
        default: cout<<"it is default case"<<endl;
                break;

    }
    cout <<endl;
    
    
}


#######################################################################################
FUNCTIONS


#include<iostream>
using namespace std;

int power (int a , int b){   // the arguements need not be 'a' and 'b' .. you can give other names like 'num1' and 'num2'
    int ans = 1;
    for (int i = 1;i<=b;i++){
        ans = ans * a;

    }
    return ans;
}
int main() {

    int a ,b;
    cin >> a >> b;

    int answer = power(a,b);
    cout << "answer is "<< answer <<endl;

    
    
}


// COMBINATION FORMULA FROM PERMUTATION AND COMBINATION

#include<iostream>
using namespace std;

int factorial(int n){
    int fact = 1;
    for (int i = 1;i<=n;i++){
        fact = fact * i;
        

    }
    return fact;

}

int nCr(int n , int r ){
    int num = factorial(n);
    int deno = factorial(r) * factorial(n-r);
    return num/deno;

}



int main(){
    int a ;
    int b ;
    cin >> a >> b;
    cout << "the answer is "<< nCr(a,b);

}

// PRIME NO.    
#include<iostream>
using namespace std;

bool isPrime(int n){
    for (int i = 2;i<n;i++){
        if (n%i==0){
            return 0;
        }
        return 1;
    }
}

int main() {
    int n;
    cin >>n;
    if (isPrime(n)){
        cout<<"is a prime no."<<endl;
    }
    else{
        cout<<"is not a prime no."<<endl;
    }
}

#############################################################################################
#############################################################################################
ARRAYS

#include<iostream>
using namespace std;

int main(){
  // intializing and printing
  /*
  int second[2] = {5,6};
  cout<<second[1];
  */
  // intializing with some values. not all values are given
  int third[15] = {2,7};
  int n = 15;
  for (int i = 0;i<=n;i++){
    cout<<third[i]<< " ";
  }

    
}


//ARRAYS WITH FUNCTIONS
#include<iostream>
using namespace std;

void printarray(int arr[] , int size){
  for(int i = 0;i<=size;i++){
    cout<<arr[i]<<" ";

  }
}

int main(){
  int third[15] = {2,7};
  printarray(third,15);
   
}



#include<iostream>
using namespace std;

int getmax(int arr[], int size){
  int max = -10000;
  for(int i = 0; i<= size;i++){
    if(arr[i]> max){
      max = arr[i];
    }
  }
  return max;
}

int getmin(int arr[], int size){
  int min = 10000;
  for(int i = 0; i<= size;i++){
    if(arr[i]< min){
      min = arr[i];
    }
  }
  return min;
}


int main() {
  int n;
  cout<<"enter the length of array";
  cin >> n;

  int num[1000000];
  
  for (int i = 0;i<=n;i++){
    cin>>num[i];
  }

  cout<<"maximum value is"<< getmax(num,n);
  cout<<"minimum value is"<< getmin(num,n);
}


// whether a number is present in the array or not

#include<iostream>
using namespace std;

bool search(int arr[], int size, int element){
  for (int i = 0;i<=size;i++){
    if (arr[i]== element){
      return 1;
    } 
  }
  return 0;
  
}
int main(){
  int arr[5] = { 5, 6, 7 , 34, 45};
  int key;
  cout<<"enter the number you want to search";
  cin >> key;
  bool found = search(arr, 5,key);
  if (found){
    cout<<"the number is present";
  }
  else{
    cout<<"the number is absent";
  }
}


// REVERSE OF ARRAY
#include<iostream>
using namespace std;

void reverse(int num[],int n){
  int start = 0;
  int end = n-1;
  while(start<=end){
    swap(num[start],num[end]);
    start++;
    end--;
    
  }
}

void printarray(int num[],int n){
  for(int i = 0;i<=n;i++){
    cout<<num[i]<<" ";
  }
  cout<<endl;
}


int main(){

  int arr[6] = {3,45,777,232,44,1};
  int brr[5] = {2,33,45,27,93};

  reverse(arr,6);
  reverse(brr,5);

  printarray(arr, 6);
  printarray(brr, 5);


}


// SUM OF ARRAY
#include<iostream>
using namespace std;

void sumofarray(int arr[] , int size){
  int sum = 0;
  for(int i = 0; i< size;i++){
    sum = sum + arr[i];
  }
  cout<<sum;
  
}


int main(){
  int num[5] = { 2 , 5 , 6 , 23 , 64 };
  sumofarray(num,5);

}


// swap alternate values
#include<iostream>
using namespace std;

void swapalternate(int arr[] ,int size){
    
    for (int i = 0;i<size;i += 2){ 
        if (i+1 < size){     
            swap(arr[i],arr[i+1]); 
        }
    }  
}
void printarray(int arr[] ,int size){
    for (int i = 0;i<size;i++){
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}
int main(){
    int num[5] = {34,45,22,78,99};
    swapalternate(num, 5);
    printarray(num,5);
}


// SORT ZERO AND ONE
#include<iostream>
using namespace std;

void printarray (int arr[] ,int n){
    for (int i = 0;i< n;i++){
        cout<<arr[i]<<" ";
    }
    cout << endl;
}


void sortzeroone(int arr[], int n){
    int left = 0;
    int right = n -1;
    while(left<right){
        while(arr[left] == 0 && left < right){
            left ++;
        }
        while(arr[right] == 1 && left < right){
            right --;
        }

        if (left<right){
            swap(arr[left],arr[right]);
            left ++;
            right --;
        }
    }
}


int main(){
    int num[8] = {0,0,1,0,1,1,0,0};
    sortzeroone(num,8);
    printarray(num,8);
}


###########################################################################

BINARY SEARCH

//BINARY SEARCH

#include<iostream>
using namespace std;

int binarysearch(int arr[], int size , int key){
    int start = 0;
    int end = size - 1;
    int mid = (start + end )/2;
    while (start<=end){
        if (arr[mid] == key){
            return mid;
        }
        if( key >arr[mid]){
            start = mid + 1;

        }
        else{
            end = mid - 1;
        }
        mid = (start + end)/2;
    }
    return -1;
}

int main(){
    int num[5] = {2,5,6,7,9};
    int ind = binarysearch(num,5,7);
    cout<< ind;
}


//first occurance in an ARRAY
#include<iostream>
using namespace std;

int firstocc(int arr[],int n,int key){
  int start = 0;
  int end = n - 1;
  int mid = start + (end - start)/2;
  int ans = -1;
  while(start<=end){
    if(arr[mid]==key){
      ans = mid;
      end = mid - 1;
      
    }
    else if (key>arr[mid]){
      start = mid + 1;
    }
    else if (key<arr[mid]){
      end = mid - 1;
    }
    mid = start + (end - start)/2;
  }
  return ans;
}

int main(){
  int even[6] = {1,2,3,3,3,5};
  cout<<"First occurence of 3 is at index "<<firstocc(even,6,3)<<endl;
  return 0;
  
}


//peak element in a mountain array
#include<iostream>
using namespace std;

int peak(int arr[], int n){
    int start = 0;
    int end = n - 1;
    int mid = start + (end - start)/2;
    while(start<end){
        if (arr[mid] < arr[mid + 1]){
            start = mid + 1;
        }
        else{
            end = mid;
        }
        mid = start + (end - start)/2;
    }
    return start;//also we can return end, as both start and end comes at the same value(the peak value) when the iteration stops.
}

int main(){
    int num[3] = {0,1,0};
    cout<<peak(num,3);
}

//pivot of an array
#include<iostream>
using namespace std;

int getpivot(int arr[],int n){
    int start = 0;
    int end = n - 1;
    int mid = start +  (end - start)/2;
    while(start<end){

        if(arr[mid]>= arr[0]){
            start= mid + 1;
        }
        else{
            end =  mid;
        }
        mid =  start +  (end - start)/2;
    }
    return start;

}

int main(){
    int num[5] = {3,8,10,1,2};
    cout<<"the pivot of the array is "<<getpivot(num,5);
}

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
IMPORTANT**********

//searching in a pivoted array
#include<iostream>
using namespace std;

int getpivot(int arr[],int n){
    int start = 0;
    int end = n - 1;
    int mid = start +  (end - start)/2;
    while(start<end){

        if(arr[mid]>= arr[0]){
            start= mid + 1;
        }
        else{
            end =  mid;
        }
        mid =  start +  (end - start)/2;
    }
    return start;

}


int binarysearch(int arr[], int s,int e , int key){
    int start = s;
    int end = e;
    int mid = (start + end )/2;
    while (start<=end){
        if (arr[mid] == key){
            return mid;
        }
        if( key >arr[mid]){
            start = mid + 1;

        }
        else{
            end = mid - 1;
        }
        mid = (start + end)/2;
    }
    return -1;
}


int searchnumber(int arr[],int n,int key){
    int pivot = getpivot(arr,n);
    if(key>=arr[pivot]&& key<=arr[n-1]){
        return binarysearch(arr,pivot,n-1,key);
    }
    else{
        return binarysearch(arr,0,pivot - 1,key);
    }
}


int main(){
    int num[5] = {3,8,10,7,1};
    cout<<"the number you wanted is in the index "<<searchnumber(num,5,10);
    
}


//SQUARE ROOT USING BINARY SEARCH

#include<iostream>
using namespace std;

int sqrtroot(int n){
    int start = 0;
    int end = n;
    int mid = start + (end - start)/2;
    int ans = -1;
    while(start<end){
        int square = mid*mid;
        if(square==n){
            return mid;
        }
        else if(square<n){
            ans = mid;
            start = mid + 1;
        }
        else{
            end = mid - 1 ;
        }
        mid = start + (end - start)/2;

    }
    return ans;
}

int main(){
    int n;
    cout<<"enter the number "<<endl;
    cin>>n;
    cout<<"the answer is "<<sqrtroot(n);
}

//BOOK ALLOCATION PROBLEM 
#include<iostream>
using namespace std;

bool ispossible(int arr[], int n ,int m,int mid ){
    int studentcount = 1;
    int pagesum = 0;
    for (int i = 0;i<n;i++){
        if(pagesum + arr[i]<=mid){
            pagesum += arr[i];
        }
        else{
            studentcount++;
            if (studentcount > m || arr[i] > mid){
                return false;
            }
            pagesum = arr[i];
        }
    }
    return true;
}

int allocatebooks(int arr[], int n,int m){
    int start = 0;
    int sum = 0;
    for(int i = 0;i<n;i++){
        sum += arr[i];
    }
    int end = sum;
    int ans = -1;
    int mid = start + (end - start)/2;

    while(start<=end){
        if(ispossible(arr,n,m,mid)){
            ans = mid;
            end = mid -1;
        }
        else{
            start = mid + 1;
        }
        mid = start + (end - start)/2;
    }
    return ans;
}

int main(){
    int num[4] = {10,20,30,40};
    cout<<allocatebooks(num,4,2);
}


######################################################################
SORTING

//SELECTIVE SORTING
#include<iostream>
using namespace std;

void selectivesorting(int arr[],int n){
    for (int i = 0;i<n-1;i++){
        int minindex = i;
        for(int j = i + 1;j<n-1;j++){
            if(arr[j] < arr[minindex]){
                minindex = j;
            }
        }
        swap(arr[minindex] ,arr[i]);
    }
    
    
}

int main(){
    int num[5] = {56,33,27,21,11};
    selectivesorting(num,5);
}


//BUBBLE SORTING

#include<iostream>
using namespace std;

void bubblesorting(int arr[],int n){
    for (int i = 0;i<n-1;i++){
        for(int j = 0;j<n-i+1;j++){
            if(arr[j]>arr[j+1]){
                swap(arr[j] , arr[j+1]);
            }
        }
    }
}


//INSERTION SORTING 

#include<iostream>
using namespace std;

void insertionsorting(int arr[],int n){
    for(int i = 1;i<n;i++){
        int temp = arr[i];
        int j = i - 1;
        for(;j>=0;j--){
            if(arr[j] > temp){
                //shift
                arr[j+1] = arr[j];
            }
            else{
                break;
            }
        }
        arr[j+ 1] = temp;
    }
}


######################################
CHARACTER ARRAYS

#include<iostream>
using namespace std;

int main(){
    char ch[20];

    cout<<"enter the name"<<endl;
    cin>>ch;
    ch[2] = '\0';

    cout<<"your name is:";
    cout<<ch;
}


//2D ARRAYS
#include<iostream>
using namespace std;

int main(){
    int arr[3][4];

    for(int i=0; i<3 ; i++){
        for(int j = 0; j<4; j++){
            cin >> arr[i][j];
        }
    }

    for(int i=0; i<3; i++){
        for(int j=0; j<4; j++){
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}

//LINEAR SEARCH IN 2D ARRAYS
#include<iostream>
using namespace std;

bool gettarget(int arr[][4],int target,int i,int j){
    
    for(int i = 0;i<3;i++){
        for(int j= 0;j<4;j++){
            if(target == arr[i][j]) {
                return 1;
            }
        }
    }
    return 0;
}


int main(){
    int arr[3][4];

    for(int i=0; i<3 ; i++){
        for(int j = 0; j<4; j++){
            cin >> arr[i][j];
        }
    }

    for(int i=0; i<3; i++){
        for(int j=0; j<4; j++){
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }

    int target;
    cout<<"enter the element you want:";
    cin>>target;
    if(gettarget(arr,target,3,4)){
        cout<<"found";
    }
    else{
        cout<<"not found";
    }



    
}

####################################################################################
MATHS FOR DSA


//GREATEST COMMON DIVISOR(GCD/HCF)
#include<iostream>
using namespace std;

int gcd(int a,int b){
    if(a==0){
        return b;
    }
    if(b==0){
        return a;
    }
    while(a!=b){
        if(a>b){
            a =a -b ;
        }
        else{
            b = b -a;
        }   
    }  
    return a; 
}

int main(){
    int a,b;
    cout<<"enter two numbers";
    cin>>a>>b;

    int ans = gcd(a,b);
    cout<<"the gcd is "<<ans;
    
}

#################################################################################
POINTERS

//ARRAY AND POINTERS
#include<iostream>
using namespace std;

int main(){
    int arr[10];
    
    cout<<"the address of the first position is"<<arr;
    // instead of 'arr' , we can write '&arr[0]'
}

##########################################
POINTERS AND FUNCTIONS

#include<iostream>
using namespace std;

void print(int *p ){
    cout<< *p<<endl;
}

void update(int *p){
    *p = *p + 1;
}

int main(){
    int value = 5;
    int *p = &value;

    //print(p)

    cout<<"before "<<*p<<endl;
    update(p);
    cout<<"after "<<*p<<endl;

    
}


###############################################################################################

STATIC AND DYNAMIC MEMORY ALLOCATION


#include<iostream>
using namespace std;

int getsum(int* arr,int n){
    int sum = 0;
    for(int i= 0;i<n;i++){
        sum += arr[i];
    }
    return sum;
}


int main(){  
    int n;
    cin >> n;

    int* arr = new int[n];
    for(int i = 0;i<n;i++){
        cin>>arr[i];
    }

    int ans = getsum(arr,n);
    cout<<"answer is "<<ans<<endl;

}

//DYNAMIC MEMORY ALLOCATION ON 2D ARRAYS

#include<iostream>
using namespace std;


int main(){
    int row;
    cin >> row;

    int col;
    cin >> col;

    //creating 2D ARRAY
    int **arr = new int*[row];
    for(int i = 0;i<row;i++){
        arr[i] = new int[col];
    }

    // taking input
    for(int i = 0;i<row;i++){
        for(int j = 0;j<col;j++){
            cin>> arr[i][j];
        }
    }

    //printing output
    for(int i = 0;i<row;i++){
        for(int j = 0;j<col;j++){
            cout<< arr[i][j]<<" ";
        }
        cout<<endl;
    }
}



###############################################################################
################################################################################
###############################################################################
RECURSION


//FACTORIAL OF A NUMBER

#include<iostream>
using namespace std;

int factorial(int n){
    //base case
    if(n == 0)
        return 1;
    
    //recursive relation
    return n*factorial(n-1);
    // also can be written as 
    // int smallerproblem = factorial(n-1);
    // int biggerproblem = n * smallerproblem;
    // return biggerproblem;
    
}


int main(){
    int n;
    cin>> n;
    cout<<factorial(n);

    
}



//LENGTH OF THE CHAR ARRAY

#include<iostream>
using namespace std;

int getlength(char num[]){
    int count = 0;
    for (int i = 0;num[i] != '\0';i++){
        count++;
    }
    return count;
}

int main(){
    char ch[20];

    cout<<"enter the name"<<endl;
    cin>>ch;

    cout<<"the length of the array is "<<getlength(ch);
}

//REVERSE OF THE CHAR ARRAY

#include<iostream>
using namespace std;

void reversearray(char num[],int n){
    int start = 0;
    int end = n - 1;
    while(start<end){
        swap(num[start++],num[end--]);
    }
}

int getlength(char num[]){
    int count = 0;
    for (int i = 0;num[i] != '\0';i++){
        count++;
    }
    return count;
}


int main(){
    char ch[20];

    cout<<"enter the name"<<endl;
    cin>>ch;
    int len = getlength(ch);
    cout<<"the reverse of the array is";
    reversearray(ch,len);
    cout<<"the name is";
    cout<<ch;
}


//FIBONACCI SERIES USING RECURSION

#include<iostream>
using namespace std;

int fib(int n){
    if(n==0){
        return 0;
    }
    if(n==1){
        return 1;
    }

    int ans = fib(n - 1) + fib(n - 2);
    return ans;

}

int main(){
    int n;
    cin>>n;
    cout<<fib(n);
}


################################################################################
RECURSION ANS BINARY SEARCH

//CHECKING IF THE ARRAY IS SORTED OR NOT

#include<iostream>
using namespace std;

bool issorted(int arr[],int size){
    if(size== 0 || size == 1){
        return true;
    }
    
    if(arr[0]>arr[1]){
        return false;
    }
    else{
        int remainingpart = issorted(arr + 1,size -1);
        return remainingpart;
    }
}


int main(){
    int arr[5] = {2,3,9,7,8};
    
    bool ans = issorted(arr,5);

    if (ans){
        cout<<"the array is sorted"<<endl;
    }
    else{
        cout<<"the array is not sorted"<<endl;
    }

}


//  RECURSION WITH LINEAR SEARCH
#include<iostream>
using namespace std;

bool linearsearch(int arr[],int size,int key){
    //BASE CASE(IF NOT FOUND)
    if(size==0){
        return false;
    }
    //BASE CASE(IF FOUND)
    if(arr[0]==key){
        return true;
    }

    bool remainingpart = linearsearch(arr + 1,size - 1,key);
    return remainingpart;
}


int main(){
    int arr[5]= {3,4,1,5,8};
    int size = 5;
    int key = 4;
    bool ans = linearsearch(arr,size,key);
    if(ans){
        cout<<"present"<<endl;
    }
    else{
        cout<<"absent"<<endl;
    }


}


//  RECURSION WITH BINARY SEARCH
#include<iostream>
using namespace std;

void print(int arr[],int start,int end){
    for(int i = start;i<end;i++){
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}


bool binarysearch(int *arr,int start,int end,int key){
    cout<<endl;
    print(arr,start,end);
    //BASE CASE
    //IF NOT FOUND

    if(start > end){
        return false;
    }

    int mid = start + (end - start)/2;
    cout<<"value of mid is"<<arr[mid]<<endl;
    //IF FOUND
    if(arr[mid]==key){
        return true;
    }

    if(arr[mid]<key){
        return binarysearch(arr,mid+1,end,key);
    }
    else{
        return binarysearch(arr,start,mid-1,key);
    }
}


int main(){
    int arr[10]= {2,3,5,6,8,12,34,58,66,99};
    
    int key = 12;
    
    cout<<"present or not ->"<<binarysearch(arr,0,9,key);
}


//RECURSION WITH STRING

#include<iostream>
using namespace std;

void revstr(string &str,int i,int j){
    if(i>j){
        return ;
    }
    swap(str[i],str[j]);
    i++;
    j--;

    return revstr(str,i,j);
}

int main(){
    string arr = "anay";
    revstr(arr,0,arr.length()-1);
    cout<<arr;

}


#############################################
MERGE SORT

#include<iostream>
using namespace std;

void merge(int *arr,int s,int e){
    int mid = (s + e)/2;

    int len1 = mid - s + 1;
    int len2 = e - mid;

    int *arr1 = new int[len1];
    int *arr2 = new int[len2];

    int mainarrayindex = s;
    for(int i = 0;i<len1;i++){
        arr1[i] = arr[mainarrayindex++];
    }

    mainarrayindex = mid + 1;
    for(int i = 0;i<len2;i++){
        arr2[i] = arr[mainarrayindex++];
    }

    //merge two sorted arrays into the previous array ,i.e, arr

    int index1 = 0;
    int index2 = 0;

    while(index1<len1 && index2 < len2){
        if(arr1[index1++]>arr2[index2++]){
            arr[mainarrayindex++] = arr1[index1]; 
        }
        else{
            arr[mainarrayindex++] = arr2[index2];
        }
    }

    while(index1<len1){
        arr[mainarrayindex++] = arr1[index1];
    }

    while(index2<len2){
        arr[mainarrayindex++] = arr2[index2];
    }
}

void mergesort(int *arr,int s,int e){
    int mid = (s+e)/2;

    if(s>=e){
        return;
    }

    //cout<<"hi";

    mergesort(arr,s,mid);

    mergesort(arr,mid + 1,e);

    merge(arr,s,e);
}

int main(){
    int arr[5] = {12,55,37,80,71};
    int n = 5;
    mergesort(arr,0,n-1);

    for(int i = 0;i<n;i++){
        cout<<arr[i]<<endl;
    }

    return 0;

}


// QUICK SORT

#include<iostream>
using namespace std;

int partition(int arr[],int s,int e){
    int pivot = arr[s];
    int count = 0;
    for(int i = s+1;i<=e;i++){
        if(arr[i]<=pivot){
            count++;
        }
    }

    int pivot_index = count + s;

    swap(arr[pivot_index],arr[s]);

    int i=s ,j = e;

    while(i<pivot_index && j>pivot_index){
        while(arr[i]<pivot){
            i++;
        }
        while(arr[j]>pivot){
            j--;
        }
        if(i<pivot_index && j>pivot_index){
            swap(arr[i++],arr[j--]);
        }

    }
    return pivot_index;
}

void quicksort(int arr[],int s,int e){
    //base case
    if(s>=e){
        return ;
    }

    int p = partition(arr,s,e);
    

    //left part sort karo
    quicksort(arr,s,p-1);

    //right part sort karo
    quicksort(arr,p+1,e);
}

int main(){
    int arr[7] = {23,19,66,47,82,34,77};
    int n = 7;
    quicksort(arr,0,n-1);
    for(int i = 0;i<n;i++){
        cout<<arr[i]<<endl;
    }
    return 0;
}


//POWER SET LOGIC ONLY(NOT FULL CODE)

void powerset(vector<int> arr,vector<int> output,int index,vector<vector<int>> &ans){
    //base case
    if(index > arr.size()){
        ans.push_back(output);
        return ;
    }

    //exclude
    powerset(arr,output,index+ 1,ans);

    //include
    int element = arr[index];
    output.push_back(element);
    powerset(arr,output,index + 1,ans);
}



################################################################################################
#######################################################################################
##################################################################################


LINKED LIST

//////////////////////////
/////// SINGLY LINKED LIST 

//BASIC OPERATION IN SINGLY LINKED LIST

#include<iostream>
using namespace std;

class node {
    public:
    int data;
    node *next ;

    // constructor create
    node(int data){
        this -> data = data;
        this -> next = NULL;
    }
};

// code to insert new node at head position
void insertAtHead(node* &head, int d){
    node *temp = new node(d);
    temp -> next = head;
    head = temp;
}

// code to print the linked list 
void print(node* &head){
    node * temp = head;

    while(temp != NULL ){
        cout<<temp->data<<endl;
        temp = temp ->next;
    }cout<<endl;
        

}





int main(){

    // new node created
    node *nd1 = new node(10);
    //cout<< nd1 -> data;

    // point the head to the new created node
    node *head = nd1;

    print(head);

    insertAtHead(head,12);

    print(head);



}


////// CODE TO INSERT ELEMENTS IN LINKED LIST AT THE BACK ( LIKE IN AN ARRAY)

#include<iostream>
using namespace std;

class node {
    public:
    int data;
    node *next ;

    // constructor create
    node(int data){
        this -> data = data;
        this -> next = NULL;
    }
};

// code to insert new node at head position
void insertAtHead(node* &head, int d){
    node *temp = new node(d);
    temp -> next = head;
    head = temp;
}

// code to insert new node at tail postion 
void insertAtTail(node* &tail,int d){
    node *temp = new node(d);
    tail -> next = temp;
    tail = temp;

}

// code to print the linked list 
void print(node* &head){
    node * temp = head;

    while(temp != NULL ){
        cout<<temp->data<<endl;
        temp = temp ->next;
    }cout<<endl;
        

}





int main(){

    // new node created
    node *nd1 = new node(10);
    //cout<< nd1 -> data;

    // point the head to the new created node
    node *head = nd1;
    node *tail = nd1;

    print(head);

    insertAtTail(tail,12);

    print(head);



}


////CODE TO INSERT NODE AT ANY POSITION

#include<iostream>
using namespace std;

class node {
    public:
    int data;
    node *next ;

    // constructor create
    node(int data){
        this -> data = data;
        this -> next = NULL;
    }
};

// code to insert new node at head position
void insertAtHead(node* &head, int d){
    node *temp = new node(d);
    temp -> next = head;
    head = temp;
}

// code to insert new node at tail postion 
void insertAtTail(node* &tail,int d){
    node *temp = new node(d);
    tail -> next = temp;
    tail = temp;

}

// code to insert at any position
void insertAtPosition(node* &tail,node* &head , int position ,int d){

    // insert at first position
    if(position == 1){
        insertAtHead(head,d);
        return;
    }

    // traverse till the required position
    node* temp = head;
    int count = 1;
    while(count <position - 1 ){
        temp = temp -> next;
        count ++;
    }

    // inserting at last position

    if(temp ->next == NULL){
        insertAtTail(tail,d);
        return;
    }

    // inserting the node
    node *nodetoinsert = new node(d);
    nodetoinsert->next = temp ->next;
    temp ->next = nodetoinsert;

}

// code to print the linked list 
void print(node* &head){
    node * temp = head;

    while(temp != NULL ){
        cout<<temp->data<<" ";
        temp = temp ->next;
    }cout<<endl;
        

}


int main(){

    // new node created
    node *nd1 = new node(10);
    //cout<< nd1 -> data;

    // point the head to the new created node
    node *head = nd1;
    node *tail = nd1;

    print(head);

    insertAtTail(tail,12);

    print(head);

    insertAtTail(tail,15);

    print(head);

    insertAtPosition(tail,head,4,22);

    print(head);

    cout<<"head"<<head ->data<<endl;
    cout<<"tail"<<tail ->data<<endl;


}

///// CODE TO DELETE FROM SINGLY LINKED LIST

#include<iostream>
using namespace std;

class node {
    public:
    int data;
    node *next ;

    // constructor create
    node(int data){
        this -> data = data;
        this -> next = NULL;
    }

    ~node (){
        if (this -> next != NULL){
            delete next;
            this -> next = NULL;
        }
    }
};

// code to insert new node at head position
void insertAtHead(node* &head, int d){
    node *temp = new node(d);
    temp -> next = head;
    head = temp;
}

// code to insert new node at tail postion 
void insertAtTail(node* &tail,int d){
    node *temp = new node(d);
    tail -> next = temp;
    tail = temp;

}

// code to insert at any position
void insertAtPosition(node* &tail,node* &head , int position ,int d){

    // insert at first position
    if(position == 1){
        insertAtHead(head,d);
        return;
    }

    // traverse till the required position
    node* temp = head;
    int count = 1;
    while(count <position - 1 ){
        temp = temp -> next;
        count ++;
    }

    // inserting at last position

    if(temp ->next == NULL){
        insertAtTail(tail,d);
        return;
    }

    // inserting the node
    node *nodetoinsert = new node(d);
    nodetoinsert->next = temp ->next;
    temp ->next = nodetoinsert;

}

// code to delete at any position
void deleteatanypos( node* &tail , node* &head, int position){
    node* temp = head;

    

    // first position
    if(position == 1){
        
        head = head -> next;
        // memory free karo
        temp ->next = NULL;
        delete temp;
    }

    // other positions
    else {
        // start count from the first position
        node* prev = NULL;
        node* curr = head;

        int count = 1;
        while(count < position){
            prev = curr;
            curr = curr -> next;
            count ++;
            
        }
        prev -> next = curr-> next;
        curr -> next = NULL;
        if(prev -> next == NULL){
            tail = prev;
        }
        delete curr;
    }
    

}

// code to print the linked list 
void print(node* &head){
    node * temp = head;

    while(temp != NULL ){
        cout<<temp->data<<" ";
        temp = temp ->next;
    }cout<<endl;
        

}


int main(){

    // new node created
    node *nd1 = new node(10);
    //cout<< nd1 -> data;

    // point the head to the new created node
    node *head = nd1;
    node *tail = nd1;

    print(head);

    insertAtTail(tail,12);

    print(head);

    insertAtTail(tail,15);

    print(head);

    insertAtPosition(tail,head,4,22);

    print(head);

    cout<<"head"<<head ->data<<endl;
    cout<<"tail"<<tail ->data<<endl;

    deleteatanypos(tail,head,4);
    print(head);

    cout<<"head"<<head ->data<<endl;
    cout<<"tail"<<tail ->data<<endl;


}


///////////
/// DOUBLY LINKED LIST

#include<iostream>
using namespace std;

class Node {
    public:
    int data;
    Node* prev;
    Node* next;

    //constructor
    Node(int data){
        this -> data = data;
        this -> prev = NULL;
        this -> next = NULL;

    }

    ~Node(){
        if(next != NULL){
            delete next;
            next = NULL;
        }
    }

};

// printing doubly linked list

void print(Node* &head){
    Node* temp = head;
    while(temp != NULL){
        cout<<temp -> data<<" ";
        temp = temp -> next;
    }
    cout<<endl;
}

// to get the length of doubly linked list 

int getlength(Node* &head){
    int count = 0;
    Node * temp = head;
    while(temp != NULL){
        count ++;
        temp = temp -> next;
    }

    return count;
}

// INSERT AT ANY POSITION
// insert at head

void insertAtHead(Node* &tail,Node* &head,int d){
    
    // empty list
    if(head == NULL){
        Node* temp  = new Node(d);
        head = temp;
        tail = temp;
    }
    else{
        Node* temp = new Node(d);
        temp -> next = head;
        head ->prev = temp;
        head = temp;
    }
    
}

// insert at tail

void insertAtTail(Node* &tail,Node* &head, int d){
    // empty list
    if(tail == NULL){
        Node* temp = new Node(d);
        tail = temp;
        head = temp;
    }
    else{
        Node* temp = new Node(d);
        tail -> next = temp;
        temp -> prev = tail;
        tail = temp;
    }
    
}

void insertAtPosition(Node* &tail,Node* &head , int position ,int d){

    // insert at first position
    if(position == 1){
        insertAtHead(tail,head,d);
        return;
    }

    // traverse till the required position
    Node* temp = head;
    int count = 1;
    while(count <position - 1 ){
        temp = temp -> next;
        count ++;
    }

    // inserting at last position

    if(temp ->next == NULL){
        insertAtTail(tail,head,d);
        return;
    }

    // inserting the node
    Node *nodetoinsert = new Node(d);
    nodetoinsert -> next = temp -> next;
    temp -> next -> prev = nodetoinsert;
    temp -> next = nodetoinsert;
    nodetoinsert -> prev = temp;

}

// code to delete at any position
void deleteatanypos( Node* &tail , Node* &head, int position){

    Node* temp = head;
    
    // first position
    if(position == 1){
        temp -> next -> prev = NULL;
        head = temp -> next;
        temp -> next = NULL;
        //memory free;
        delete temp;

    }

    // other positions
    else {
        // start count from the first position
        Node* prev = NULL;
        Node* curr = head;

        int count = 1;
        while(count < position){
            prev = curr;
            curr = curr -> next;
            count ++;
            
        }
        curr -> prev = NULL;
        prev -> next = curr -> next;
        curr -> next = NULL;
        if(prev -> next == NULL){
            tail = prev;
        }
        delete curr;
    }
    

}

int main(){
    Node* head = NULL;
    Node* tail = NULL;
    print(head);
    
    insertAtHead(tail,head,14);
    insertAtTail(tail,head,17);
    print(head);
    //cout<< getlength(head);

    insertAtPosition(tail,head,2,100);
    print(head);
    insertAtPosition(tail,head,4,110);
    print(head);
    deleteatanypos(tail,head,3);
    print(head);
    cout<<"head"<<head->data<<endl;
    cout<<"tail"<<tail->data<<endl;
    deleteatanypos(tail,head,3);
    print(head);
    cout<<"head"<<head->data<<endl;
    cout<<"tail"<<tail->data<<endl;



}

////////
///CIRCULAR LINKED LIST



#include<iostream>
using namespace std;

class Node{
    public:
    int data;
    Node* next;

    //constructor
    Node(int data){
        this ->data = data;
        this ->next = NULL;
    }

    //destructor
    ~Node(){
        if(this->next != NULL){
            delete next;
            next = NULL;
        }
    }
};


void insertatanypos(Node* &tail, int element ,int d){
    //for first node creation

    if(tail == NULL){
        Node* newnode = new Node(d);
        tail = newnode;
        newnode->next = newnode;
    }

    //for further node creations
    Node* curr = tail;

    while(curr->data != element){
        curr = curr->next;
    }
    Node* temp = new Node(d);
    temp ->next = curr-> next;
    curr -> next = temp;
}

void print(Node* &tail){
    Node* temp = tail;
    if(tail == NULL){
        cout<<"list is empty"<<endl;
        return;
    }
    do{
        cout<<tail->data<<endl;
        tail = tail ->next;
    }while(tail!= temp);
    cout<<endl;
}

void deleteatpos(Node* &tail, int value){
    // for only one node
    if(tail == NULL){
        cout<<"list is empty ,please check again"<<endl;
        return ;
    }
    //for one or more than one nodes
    else{
        
        Node* prev = tail;
        Node* curr = prev -> next;

        while(curr->data != value){
            prev = curr;
            curr = curr -> next;
        }

        prev ->next = curr->next;

        //for 1 node
        if(prev == curr){
            tail = NULL;
        }
        //for 2 or more
        else if(tail == curr){
            tail = prev;
        }

        curr -> next = NULL;
        delete curr;

    }
}

int main(){

    Node* tail = NULL;

    insertatanypos(tail,4,3);
    print(tail);

    insertatanypos(tail,3,5);
    print(tail);

    deleteatpos(tail,5);
    print(tail);


}


/// RECURSIVE WAY OF REVERSING A LINKED LIST 

#include<iostream>
using namespace std;

class Node{
    public:
    int data;
    Node* next;

    Node(int data){
        this -> data = data;
        this -> next = NULL;
    }
};

void reverselinkedlist(Node* &head, Node* curr , Node* prev){
    // base case
    if(curr == NULL){
        head = prev;
        return;
    }

    Node* forward = curr -> next;
    reverselinkedlist(head,forward,curr);
    // ek case solve karo
    curr -> next = prev;
}


//// CODE TO GET THE MIDDLE OF LINKED LIST 

#include<iostream>
using namespace std;

class Node{
    public:
    int data;
    Node* next;

    Node(int data){
        this -> data = data;
        this -> next = NULL;
    }
};

int getlength(Node* &head){
    int count = 0;
    while(head != NULL){
        count ++;
        head = head -> next;
    }

    return count ;
}

int lengthoflinkedlist(Node* &head){
    int length = getlength(head);
    int ans = (length+1)/2;
    return ans;
}


                         /////ANOTHER EFFICIENT WAY /////

#include<iostream>
using namespace std;

class Node{
    public:
    int data;
    Node* next;

    Node(int data){
        this -> data = data;
        this -> next = NULL;
    }
};

Node* middleoflinkedlist(Node* head){
    // for the length of 0 or 1
    if(head == NULL || head -> next == NULL){
        return head;
    }
    // for the length of 2
    if(head -> next -> next == NULL){
        return head -> next;
    }

    Node* slow = head;
    Node* fast = head -> next;

    while(fast != NULL){
        fast = fast -> next;
        if(fast != NULL){
            fast = fast -> next;
        }
        slow = slow -> next;
    }
    return slow;


}

/////LOGIC OF REVERSE OF LINKED LIST (NOT FULL CODE)

#include<iostream>
using namespace std;

class Node{
    public:
    int data;
    Node* next;

    Node(int data){
        this -> data = data;
        this -> next = NULL;
    }
};


// here the function has to be made of Node* type . int type or void type wont work .
Node* revlkl(Node* &head){
    if(head == NULL || head -> next == NULL){
        return head;
    }
    Node* prev = NULL;
    Node* curr = head;
    Node* forward = curr -> next;
    while(curr != NULL){
        forward = curr -> next;
        curr -> next = prev;
        prev = curr;
        curr = forward;
        
    }
    return prev;
}


/////// REVERSE OF LINKED LIST IN K GROUPS 

#include<iostream>
using namespace std;

class Node{
    public:
    int data;
    Node* next;

    Node(int data){
        this -> data = data;
        this -> next = NULL;
    }
};

Node* kreverse(Node* head,int k){
    //base condition
    if(head == NULL){
        return NULL;
    }

    // Step 1: reverse one case
    Node* prev = NULL;
    Node* curr = head;
    Node* forward = NULL;
    int count = 0;
    while(curr != NULL && count < k){
        forward = curr -> next;
        curr -> next = prev;
        prev = curr;
        curr = forward;
        count ++;
    }

    //step 2: recursion will handle rest
    if(forward != NULL){
        head -> next = kreverse(forward,k);
    }

    //step 3: return head of linked list
    return prev;
}


/////CODE TO CHECK WHETHER A LINKED LIST IS CIRCULAR OR NOT


#include<iostream>
using namespace std;

class Node{
    public:
    int data;
    Node* next;

    Node(int data){
        this -> data = data;
        this -> next = NULL;
    }
};

bool iscircular(Node* head){
    // zero nodes
    if(head == NULL){
        return true;
    }
    // 1 or more than 1 node

    Node* temp = head -> next;
    while(temp != head && temp != NULL){
        temp = temp -> next;
    }
    if(temp == head){
        return true;
    }

    return false;
}

int main(){
    if(iscircular){
        cout<<"linked list is circular in nature"<<endl;
    }
    else{
        cout<<"linked list is not circular "<<endl;
    }
}


//// CODE TO REMOVE DUPLICATE ELEMENTS IN A SORTED LINKED LIST


#include<iostream>
using namespace std;

class Node{
    public:
    int data;
    Node* next;

    Node(int data){
        this -> data = data;
        this -> next = NULL;
    }
    ~Node(){
        if(this -> next != NULL){
            delete next;
            next = NULL;
        }
    }
};

void removeduplicate(Node* head){
    // zero nodes
    if(head == NULL){
        return ;
    }

    // one or more than one 
    Node* curr = head;
    while(curr != NULL){
        if((curr -> next != NULL) && curr -> data  == curr -> next -> data){
            Node* next_next = curr -> next -> next;
            Node* nodetodelete = curr ->next;
            delete(nodetodelete);
            curr -> next = next_next;
        }
    }
    return head;
}



////// SORT ZERO AND ONE

#include<iostream>
using namespace std;

class Node{
    public:
    int data;
    Node* next;

    Node(int data){
        this -> data = data;
        this -> next = NULL;
    }
    ~Node(){
        if(this -> next != NULL){
            delete next;
            next = NULL;
        }
    }
};

Node* sortzeroonetwo(Node* head){
    int zerocount = 0;
    int onecount = 0;
    int twocount = 0;
    Node* temp = head;
    while(temp != NULL){
        if(temp -> data == 0){
            zerocount++;
        }
        else if(temp->data == 1){
            onecount++;
        }
        else if(temp->data == 2){
            twocount++;
        }
        temp = temp -> next;
    }

    while(temp != NULL){
        if(zerocount != 0){
            temp ->data = 0;
            zerocount--;
        }
        else if(onecount != 0){
            temp -> data = 1;
            onecount--;
        }
        else if(twocount != 0){
            temp -> data = 2;
            twocount--;
        }
        temp = temp -> next;
    }
    return head;
}


///// MERGE SORT IN LINKED LIST 

#include<iostream>
using namespace std;

class Node{
    public:
    int data;
    Node* next;

    Node(int data){
        this -> data = data;
        this -> next = NULL;
    }
    ~Node(){
        if(this -> next != NULL){
            delete next;
            next = NULL;
        }
    }
};

Node* findmid(Node* head){
    Node* slow = head;
    Node* fast = head -> next;
    while(fast != NULL && fast ->next != NULL){
        slow = slow -> next;
        fast = fast -> next -> next;
    }
}

Node* merge(Node* left , Node* right){
    if( left == NULL){
        return right;
    }
    else if(right == NULL){
        return left;
    }

    Node* ans = new Node(-1);
    Node* temp = ans;
    while(left != NULL && right != NULL){
        if(left -> data < right -> data){
            temp -> next = left;
            temp = left;
            left = left -> next;
        }
        else{
            temp -> next = right;
            temp = right;
            right = right -> next;
        }

    }
    while(left != NULL){
        temp -> next = left;
        temp = left;
        left = left -> next;
    }

    while(right != NULL){
        temp -> next = right;
        temp = right;
        right = right -> next;
    }
    ans = ans -> next;
    return ans;
}

Node* mergesort(Node* head){
    // base case
    if(head == NULL || head -> next == NULL){
        return head;
    }
    Node* mid = findmid(head);
    Node* left = head;
    Node* right = mid -> next;
    mid -> next = NULL;

    // apply recursion to sort the left and right part
    left = mergesort(head);
    right = mergesort(head);

    Node* result = merge(left,right);
    return result;
}




#######################################################################################
######################################

STACKS

//// BASICS OF STACKS 

#include<iostream>
#include<stack>
using namespace std;

class Stack{
    public:
    int *arr;
    int size;
    int top;

    //constructor(or behaviour)
    Stack(int size){
        this -> size = size;
        arr = new int[size];
        top = -1;
    }

    void push(int element){
        if(size - top > 1){
            top ++;
            arr[top] = element;
        }
        else{
            cout<<"stack overflow";
        }
    }

    void pop(){
        if(top >= 0){
            top --;
        }
        else{
            cout<<"stack underflow";
        }
    }

    int peek(){
        if(top >= 0){
            return arr[top];
        }
    }

    bool isempty(){
        if(top == -1 ){
            return true ;
        }
        else{
            return false;
        }
    }

};

int main(){
    Stack st(5);

    st.push(34);
    st.push(43);
    st.push(74);

    cout<<st.peek()<<endl;
    st.pop();
    cout<<st.peek()<<endl;

    // to print the array stack
    while(st.isempty()!= true){
        cout<<st.peek()<<endl;
        st.pop();
    }

}


/////////TWO STACKKS IN AN ARRAY

#include<iostream>
#include<stack>
using namespace std;

class Stack{
    public:
    int *arr;
    int size;
    int top1;
    int top2;

    //constructor(or behaviour)
    Stack(int size){
        this -> size = size;
        arr = new int[size];
        top1 = -1;
        top2 = size;
    }

    void push1(int element){
        if(top2 - top1 > 1){
            top1 ++;
            arr[top1] = element;
        }
        else{
            cout<<"stack overflow";
        }
    }

    void push2(int element){
        if(top2 - top1 > 1){
            top2 --;
            arr[top2] = element;
        }
        else{
            cout<<"stack overflow";
        }
    }

    void pop1(){
        if(top1 >= 0){
            top1 --;
        }
        else{
            cout<<"stack underflow";
        }
    }

    void pop2(){
        if(top2 < size){
            top2 ++;
        }
        else{
            cout<<"stack underflow";
        }

    }

    int peek(){
        if(top1 >= 0 && top2 < size){
            return arr[top1];
        }
    }

    

};

int main(){
    Stack st(10);
    st.push1(5);
    st.push2(34);
    st.push1(44);
    st.push1(78);
    st.push2(22);

    cout<<st.peek();
}


///// REMOVE MIDDLE ELEMENT OF A STACK

<<<<< LOGIC ONLY >>>>>

void deletemidddle(Stack* &inputstack,int count,int size){
    // base case
    if(count == size/2){
        inputstack.pop();
        return;
    }

    int num = inputstack.top();
    inputstack.pop();

    // call recursion

    deletemidddle(inputstack,count + 1,size);

    inputstack.push(num);
}



##################################################################################
#######################################################################
QUEUE

//// BASIC IMPLEMENTATION USING CLASS

#include<iostream>
#include<queue>
using namespace std;


class Queue{
    public:
    int front;
    int rear;
    int *arr;
    int size;

    Queue(){
        size = 10000001; // random size , as queue constructor doesn't take any size as parameter
        arr = new int[size];
        front = 0;
        rear = 0;

    }


    void enqueue(int element){
        if(rear == size){
            cout<<"queue is full";
        }
        else{
            arr[rear] = element;
            rear ++;
        }
    }

    int dequeue(){
        int ans = arr[front];
        if(front == rear){
            cout<<"queue is empty";
        }
        else{
            arr[front] = -1;
            front ++;
            if(front == rear){
                front = 0;
                rear = 0;
            }

        }
        return ans;
    }

    bool isempty(){
        if(front == rear){
            return true;
        }
        else{
            return false;
        }
    }

    int qfront(){
        if(front == rear){
            return -1;
        }
        else{
            return arr[front];
        }
    }


};  



int main(){
    queue<int> q;

    
}




////// BASIC IMPLEMENTATION OF CIRCULAR QUEUE


#include<iostream>
#include<queue>
using namespace std;

class CircularQueue{
    public:
    int *arr;
    int front;
    int rear;
    int size;

    CircularQueue(int size){
        this -> size = size;
        arr = new int[size];
        front = -1;
        rear = -1;

    }

    void push(int element){
        if((front == 0 && rear == size -1 ) || (rear == (front - 1)%(size -1 ))){
            cout<<"full queue" ;
        }
        else if(front == -1){
            front = 0;
            rear = 0;
            arr[rear] = element;
        }
        else if((rear == size -1)&& (front != 0)){
            rear = 0;
            arr[rear] = element;
        }
        else{
            rear ++;
            arr[rear] = element;
        }
    }

    int pop(){
        if(front == -1){
            cout<<"empty queue";
        }
        int ans = arr[front];
        arr[front] = -1;
        if(front == rear){
            front = rear = -1;
        }
        else if(front == size -1){
            front = 0;
        }
        else{
            front ++;
        }
    }



};



/////// REVERSE A QUEUE USING STACK

#include<iostream>
#include<stack>
#include<queue>
using namespace std;

int main(){
    queue<int> q;
    q.push(5);
    q.push(6);
    q.push(4);
    q.push(9);
    q.push(7);
    stack<int> s;

    while(!q.empty()){
        int element = q.front();
        q.pop();
        s.push(element);
    }
    while(!s.empty()){
        int element = s.top();
        s.pop();
        q.push(element);
    }

    while(!q.empty()){
        cout<<q.front()<<endl;
        q.pop();
    }

}


///// REVERSE OF FIRST K ELEMENTS IN QUEUE

#include<iostream>
#include<stack>
#include<queue>
using namespace std;

int main(){
    queue<int> q;
    q.push(5);
    q.push(6);
    q.push(4);
    q.push(9);
    q.push(7);
    stack<int> s;

    int k;
    cout<<"enter k"<<endl;
    cin>>k;
    

    for(int i = 0;i<k;i++){
        int element = q.front();
        q.pop();
        s.push(element);
    }

    while(!s.empty()){
        int element = s.top();
        s.pop();
        q.push(element);
    }

    int remaining = q.size() - k;
    while(remaining--){
        int val = q.front();
        q.pop();
        q.push(val);
    }

    while(!q.empty()){
        cout<<q.front()<<endl;
        q.pop();
    }

}



//// INTERLEAVING ELEMENTS OF QUEUE USING STACK

#include<iostream>
#include<stack>
#include<queue>
using namespace std;

int main(){
    queue<int> q;
    stack<int> s;

    q.push(11);
    q.push(12);
    q.push(13);
    q.push(14);
    q.push(15);
    q.push(16);
    q.push(17);
    q.push(18);

    int len = (q.size())/2;

    for(int i = 0;i<len;i++){
        int element = q.front();
        q.pop();
        s.push(element);
    }

    while(!s.empty()){
        int element = s.top();
        s.pop();
        q.push(element);
    }

    
    int i = 0;
    while(i<len){
        int val = q.front();
        q.pop();
        q.push(val);
        i++;
    }

    for(int i = 0;i<len;i++){
        int element = q.front();
        q.pop();
        s.push(element);
    }

    while(!s.empty()){
        int val = s.top();
        s.pop();
        q.push(val);
        val = q.front();
        q.pop();
        q.push(val); 
    }

    
    while(!q.empty()){
        cout<<q.front()<<endl;
        q.pop();
    }

    

}

#########################################################################################
########################################################################################
#######################################################################################
BINARY TREE

//// BINARY TREE PROBLEM ON SIMILIARITY OF BOTH TREES

#include<iostream>
#include<queue>
using namespace std;

class node{
    public:
    int data;
    node* left;
    node* right;

    node(int d){
        this -> data = d;
        this -> left = NULL;
        this -> right = NULL;

    }
};

bool similar(node* root1,node* root2){
    if(root1 == NULL && root2 == NULL){
        return true;
    }
    if(root1 == NULL && root2 != NULL ){
        return false;
    }
    if(root2 != NULL && root2 == NULL){
        return false;
    }

    bool left = similar(root1 -> left,root2 ->left);
    bool right = similar(root1 -> right,root2 -> right);
    bool value = root1 ->data == root2 ->data;
    if(left && right && value){
        return true;
    }
    else{
        return false;
    }
}



////// CODE TO CHECK SUM OF ROOT EQUAL TO LEFT ANS RIGHT 

#include<iostream>
#include<queue>
using namespace std;

class node{
    public:
    int data;
    node* left;
    node* right;

    node(int d){
        this -> data = d;
        this -> left = NULL;
        this -> right = NULL;

    }
    public:

    pair<bool,int> issumfast(node* root){
    // base case 
    if(root == NULL){
        pair<bool,int> p = make_pair(true,0);
        return p;
    }
    if(root->left == NULL && root->right == NULL){
        pair<bool,int> p = make_pair(true,0);
        return p;
    }

    pair<bool,int> leftans = issumfast(root->left);
    pair<bool,int> rightans = issumfast(root->right);

    bool isleft = leftans.first;
    bool isright = rightans.first;

    int sumleft = leftans.second;
    int sumright = rightans.second;

    bool condn = root ->data == sumleft + sumright;

    pair<bool,int> ans ;

    if(isleft && isright && condn){
        ans.first = true;
        ans.second = sumleft + sumright + root->data;
    }
    else{
        ans.first = false;
    }
    
    return ans;
}

    
    bool issum(node* root){
        return issumfast(root).first;
    }

};



#############################################################################
###################################################################

BINARY SEARCH TREE

#include<iostream>
#include<queue>
using namespace std;

class Node{
    public:
    int data;
    Node* left ;
    Node* right;

    Node(int d){
        this -> data = d;
        this -> left = NULL;
        this -> right = NULL;
    }

};

void levelordertraversal(Node* root){
    queue<Node*> q;
    q.push(root);
    q.push(NULL);
    while(!q.empty()){
        Node* temp = q.front();
        q.pop();
        if(temp == NULL){
            cout<<endl;
            if(!q.empty()){
                q.push(NULL);
            }
        }
        else{
            cout<<temp -> data<<" ";
            if(temp -> left){
                q.push(temp->left);
            }
            if(temp -> right){
                q.push(temp ->right);
            }
        }
    }
}

Node* insertbts(Node* root,int d){
    // base case
    if(root == NULL){
        root = new Node(d);
        return root;
    }

    if(d > root->data){
        root -> right = insertbts(root -> right,d);
    }
    else{
        root -> left = insertbts(root -> left ,d);
    }

    return root;
}

void getinput(Node* &root){
    int data;
    cin>>data;

    while(data != -1){
        root = insertbts(root,data);
        cin>> data;
    }
}



int main(){

    Node* root = NULL;
    cout<<"enter the data for binary search tree"<<endl;
    getinput(root);

    cout<<"printing the binary tree"<<endl;
    levelordertraversal(root);

}



///// DELETING FROM BINARY SEARCH TREE

#include<iostream>
#include<queue>
using namespace std;

class Node{
    public:
    int data;
    Node* left ;
    Node* right;

    Node(int d){
        this -> data = d;
        this -> left = NULL;
        this -> right = NULL;
    }

};

void levelordertraversal(Node* root){
    queue<Node*> q;
    q.push(root);
    q.push(NULL);
    while(!q.empty()){
        Node* temp = q.front();
        q.pop();
        if(temp == NULL){
            cout<<endl;
            if(!q.empty()){
                q.push(NULL);
            }
        }
        else{
            cout<<temp -> data<<" ";
            if(temp -> left){
                q.push(temp->left);
            }
            if(temp -> right){
                q.push(temp ->right);
            }
        }
    }
}

Node* insertbst(Node* root,int d){
    // base case
    if(root == NULL){
        root = new Node(d);
        return root;
    }

    if(d > root->data){
        root -> right = insertbst(root -> right,d);
    }
    else{
        root -> left = insertbst(root -> left ,d);
    }

    return root;
}

void getinput(Node* &root){
    int data;
    cin>>data;

    while(data != -1){
        root = insertbst(root,data);
        cin>> data;
    }
}

Node* minval(Node* root){
    Node* temp = root;
    while(temp->left != NULL){
        temp = temp -> left;
    }
    return temp;
}

Node* maxval(Node* root){
    Node* temp = root;
    while(temp->right != NULL){
        temp = temp -> right;
    }
    return temp;
}

Node* deletebst(Node* root,int x){
    // base case
    if(root == NULL){
        return root;
    }

    if(root-> data == x){
        // 0 children
        if(root->left == NULL && root->right == NULL){
            delete root;
            return NULL;
        }

        // 1 child
        
        // left child
        if(root->left != NULL && root->right == NULL){
            Node* temp = root -> left;
            delete root;
            return temp;
        }

        // right child
        if(root->left == NULL && root->right != NULL){
            Node* temp = root -> right;
            delete root;
            return temp;
        }


        // 2 children
        if(root->left != NULL && root->right != NULL){
            int mini = minval(root->right) ->data;
            root -> data = mini;
            root -> right = deletebst(root->right,mini);
            return root;
        }
    }

    else if(x > root->data){
        root -> right = deletebst(root->right,x);
    }

    else{
        root -> left = deletebst(root->left,x);
    }
    
}

int main(){

    Node* root = NULL;
    cout<<"enter the data for binary search tree"<<endl;
    getinput(root);

    cout<<"printing the binary tree"<<endl;
    levelordertraversal(root);

    deletebst(root,27);

    cout<<"printing the binary tree"<<endl;
    levelordertraversal(root);



}

//////// VALIDATE BINARY SEARCH TREE


#include<iostream>
#include<queue>
using namespace std;

class Node{
    public:
    int data;
    Node* left ;
    Node* right;

    Node(int d){
        this -> data = d;
        this -> left = NULL;
        this -> right = NULL;
    }

};

void levelordertraversal(Node* root){
    queue<Node*> q;
    q.push(root);
    q.push(NULL);
    while(!q.empty()){
        Node* temp = q.front();
        q.pop();
        if(temp == NULL){
            cout<<endl;
            if(!q.empty()){
                q.push(NULL);
            }
        }
        else{
            cout<<temp -> data<<" ";
            if(temp -> left){
                q.push(temp->left);
            }
            if(temp -> right){
                q.push(temp ->right);
            }
        }
    }
}

Node* insertbst(Node* root,int d){
    // base case
    if(root == NULL){
        root = new Node(d);
        return root;
    }

    if(d > root->data){
        root -> right = insertbst(root -> right,d);
    }
    else{
        root -> left = insertbst(root -> left ,d);
    }

    return root;
}

void getinput(Node* &root){
    int data;
    cin>>data;

    while(data != -1){
        root = insertbst(root,data);
        cin>> data;
    }
}

Node* minval(Node* root){
    Node* temp = root;
    while(temp->left != NULL){
        temp = temp -> left;
    }
    return temp;
}

Node* maxval(Node* root){
    Node* temp = root;
    while(temp->right != NULL){
        temp = temp -> right;
    }
    return temp;
}
/*
Node* deletebst(Node* root,int x){
    // base case
    if(root == NULL){
        return root;
    }

    if(root-> data == x){
        // 0 children
        if(root->left == NULL && root->right == NULL){
            delete root;
            return NULL;
        }

        // 1 child
        
        // left child
        if(root->left != NULL && root->right == NULL){
            Node* temp = root -> left;
            delete root;
            return temp;
        }

        // right child
        if(root->left == NULL && root->right != NULL){
            Node* temp = root -> right;
            delete root;
            return temp;
        }


        // 2 children
        if(root->left != NULL && root->right != NULL){
            int mini = minval(root->right) ->data;
            root -> data = mini;
            root -> right = deletebst(root->right,mini);
            return root;
        }
    }

    else if(x > root->data){
        root -> right = deletebst(root->right,x);
    }

    else{
        root -> left = deletebst(root->left,x);
    }
    
}
*/

bool validatebst(Node* root , int min,int max){
    if(root == NULL){
        return true;
    }
    if(root->data >= min && root->data <= max){
        bool left = validatebst(root->left,min,root->data);
        bool right = validatebst(root->right,root->data,max);
        return left && right;
    }
    else{
        return false;
    }
}

int main(){

    Node* root = NULL;
    cout<<"enter the data for binary search tree"<<endl;
    getinput(root);

    cout<<"printing the binary tree"<<endl;
    levelordertraversal(root);

    bool vali = validatebst(root,-100000,100000);
    if(vali){
        cout<<"valid";
    }
    else{
        cout<<"not valid";
    }
    

}


//// BINARY SEARCH TREE KTH SMALLEST ELEMENT 
#include<iostream>
#include<queue>
using namespace std;

class Node{
    public:
    int data;
    Node* left ;
    Node* right;

    Node(int d){
        this -> data = d;
        this -> left = NULL;
        this -> right = NULL;
    }

};

void levelordertraversal(Node* root){
    queue<Node*> q;
    q.push(root);
    q.push(NULL);
    while(!q.empty()){
        Node* temp = q.front();
        q.pop();
        if(temp == NULL){
            cout<<endl;
            if(!q.empty()){
                q.push(NULL);
            }
        }
        else{
            cout<<temp -> data<<" ";
            if(temp -> left){
                q.push(temp->left);
            }
            if(temp -> right){
                q.push(temp ->right);
            }
        }
    }
}

Node* insertbst(Node* root,int d){
    // base case
    if(root == NULL){
        root = new Node(d);
        return root;
    }

    if(d > root->data){
        root -> right = insertbst(root -> right,d);
    }
    else{
        root -> left = insertbst(root -> left ,d);
    }

    return root;
}

void getinput(Node* &root){
    int data;
    cin>>data;

    while(data != -1){
        root = insertbst(root,data);
        cin>> data;
    }
}

int kthsmallestelement(Node* root,int &i,int k){
    if(root == NULL){
        return -1;
    }

    //L
    int left = kthsmallestelement(root->left,i,k);
    if(left != -1){
        return left;
    }
    //N
    i++;
    if(i==k){
        return root->data;
    }
    //R
    return kthsmallestelement(root->right,i,k);
}


int main(){

    Node* root = NULL;
    cout<<"enter the data for binary search tree"<<endl;
    getinput(root);

    cout<<"printing the binary tree"<<endl;
    levelordertraversal(root);

    int i = 0;
    int ans  = kthsmallestelement(root,i,3);
    cout<<ans;
    
    

}



//// FINDING LEAST COMMON ANCESTOR IN A BST

#include<iostream>
#include<queue>
using namespace std;

class Node{
    public:
    int data;
    Node* left ;
    Node* right;

    Node(int d){
        this -> data = d;
        this -> left = NULL;
        this -> right = NULL;
    }

};

void levelordertraversal(Node* root){
    queue<Node*> q;
    q.push(root);
    q.push(NULL);
    while(!q.empty()){
        Node* temp = q.front();
        q.pop();
        if(temp == NULL){
            cout<<endl;
            if(!q.empty()){
                q.push(NULL);
            }
        }
        else{
            cout<<temp -> data<<" ";
            if(temp -> left){
                q.push(temp->left);
            }
            if(temp -> right){
                q.push(temp ->right);
            }
        }
    }
}

Node* insertbst(Node* root,int d){
    // base case
    if(root == NULL){
        root = new Node(d);
        return root;
    }

    if(d > root->data){
        root -> right = insertbst(root -> right,d);
    }
    else{
        root -> left = insertbst(root -> left ,d);
    }

    return root;
}

void getinput(Node* &root){
    int data;
    cin>>data;

    while(data != -1){
        root = insertbst(root,data);
        cin>> data;
    }
}

Node* findlca(Node* root,int p,int q){

    while(root != NULL){
        if(root->data >p && root->data > q){
            root = root -> left;
        }
        else if(root->data < p && root->data < q){
            root = root -> right;
        }
        else{
            return root;
        }
    }
}

int main(){

    Node* root = NULL;
    cout<<"enter the data for binary search tree"<<endl;
    getinput(root);

    cout<<"printing the binary tree"<<endl;
    levelordertraversal(root);

    Node* lca = findlca(root,5,27);
    cout<<lca->data;


}


//// CODE TO FIND TWOSUM IN BST

#include<iostream>
#include<vector>
#include<queue>
using namespace std;

class Node{
    public:
    int data;
    Node* left ;
    Node* right;

    Node(int d){
        this -> data = d;
        this -> left = NULL;
        this -> right = NULL;
    }

};

void levelordertraversal(Node* root){
    queue<Node*> q;
    q.push(root);
    q.push(NULL);
    while(!q.empty()){
        Node* temp = q.front();
        q.pop();
        if(temp == NULL){
            cout<<endl;
            if(!q.empty()){
                q.push(NULL);
            }
        }
        else{
            cout<<temp -> data<<" ";
            if(temp -> left){
                q.push(temp->left);
            }
            if(temp -> right){
                q.push(temp ->right);
            }
        }
    }
}

Node* insertbst(Node* root,int d){
    // base case
    if(root == NULL){
        root = new Node(d);
        return root;
    }

    if(d > root->data){
        root -> right = insertbst(root -> right,d);
    }
    else{
        root -> left = insertbst(root -> left ,d);
    }

    return root;
}

void getinput(Node* &root){
    int data;
    cin>>data;

    while(data != -1){
        root = insertbst(root,data);
        cin>> data;
    }
}

// code to insert the inorder elements of bst in an array
void inorder(Node* root,vector<int> &arr){
    if(root == NULL){
        return;
    }

    inorder(root->left,arr);
    arr.push_back(root->data);
    inorder(root->right,arr);
}


bool twosumbst(Node* root,int target){
    vector<int> val;
    inorder(root,val);

    int i = 0;
    int j = val.size() - 1;
    while(i<j){
        int sum = val[i] + val[j];
        if(sum == target){
            return true;
        }
        else if(sum > target){
            j--;
        }
        else{
            i++;
        }
    }
    return false;
}


int main(){

    Node* root = NULL;
    cout<<"enter the data for binary search tree"<<endl;
    getinput(root);

    cout<<"printing the binary tree"<<endl;
    levelordertraversal(root);

    bool isthere = twosumbst(root,29);
    if(isthere){
        cout<<"true";
    }
    else{
        cout<<"false";
    }

    


}



///////// FLATTEN A BST INTO A LINKED LIST

#include<iostream>
#include<vector>
#include<queue>
using namespace std;

class Node{
    public:
    int data;
    Node* left ;
    Node* right;

    Node(int d){
        this -> data = d;
        this -> left = NULL;
        this -> right = NULL;
    }

};

void levelordertraversal(Node* root){
    queue<Node*> q;
    q.push(root);
    q.push(NULL);
    while(!q.empty()){
        Node* temp = q.front();
        q.pop();
        if(temp == NULL){
            cout<<endl;
            if(!q.empty()){
                q.push(NULL);
            }
        }
        else{
            cout<<temp -> data<<" ";
            if(temp -> left){
                q.push(temp->left);
            }
            if(temp -> right){
                q.push(temp ->right);
            }
        }
    }
}

Node* insertbst(Node* root,int d){
    // base case
    if(root == NULL){
        root = new Node(d);
        return root;
    }

    if(d > root->data){
        root -> right = insertbst(root -> right,d);
    }
    else{
        root -> left = insertbst(root -> left ,d);
    }

    return root;
}

void getinput(Node* &root){
    int data;
    cin>>data;

    while(data != -1){
        root = insertbst(root,data);
        cin>> data;
    }
}

// code to insert the inorder elements of bst in an array
void inorder(Node* root,vector<int> &arr){
    if(root == NULL){
        return;
    }

    inorder(root->left,arr);
    arr.push_back(root->data);
    inorder(root->right,arr);
}



void fltnbsttoll(Node* root){
    vector<int> val;
    inorder(root,val);

    int n = val.size();
    Node* newroot = new Node(val[0]);
    Node* curr = newroot;

    for(int i = 0;i<n;i++){
        Node* temp = new Node(val[i]);
        curr -> right = temp;
        curr -> left = NULL;
        curr = temp;


    }

    curr -> right = NULL;
    curr -> left = NULL;

    
}



int main(){

    Node* root = NULL;
    cout<<"enter the data for binary search tree"<<endl;
    getinput(root);

    cout<<"printing the binary tree"<<endl;
    levelordertraversal(root);

    fltnbsttoll(root);


}

